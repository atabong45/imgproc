Project Context From: /home/atabong/Documents/projet/imgproc
Generated On: mer. 24 d√©c. 2025 16:35:21 CET
===============================================
Ignored Directory Patterns: .* node_modules vendor build dist target __pycache__ .next cache target venv storage
Ignored File Patterns: *.log *.jar *.pdf *.png *.jpg *.class *.sqlite *.csv project_context.txt package-lock.json yarn.lock composer.lock *.ico pnpm-lock.yaml
===============================================

//---> PATH: /home/atabong/Documents/projet/imgproc/.gitignore

build/
bin/
*.o
// END OF FILE: .gitignore

//---> PATH: /home/atabong/Documents/projet/imgproc/include/analysis/histogram.h

#ifndef HISTOGRAM_H
#define HISTOGRAM_H

#include "core/image.h" // On a besoin de la d√©finition de la structure Image

/**
 * @brief Calcule l'histogramme d'une image en niveaux de gris.
 *
 * @param img L'image source.
 * @param histogram Un tableau d'entiers (de taille 256) pour stocker l'histogramme.
 *        histogram[i] contiendra le nombre de pixels de niveau de gris i.
 *        Ce tableau doit √™tre allou√© par l'appelant.
 */
void calculate_histogram(const Image *img, int *histogram);


/**
 * @brief Cr√©e une image repr√©sentant l'histogramme.
 *
 * @param histogram Le tableau d'entiers (taille 256) contenant l'histogramme.
 * @param width La largeur souhait√©e pour l'image de l'histogramme.
 * @param height La hauteur souhait√©e pour l'image de l'histogramme.
 * @return Un pointeur vers une nouvelle Image PGM repr√©sentant l'histogramme,
 *         ou NULL en cas d'erreur.
 */
Image *create_histogram_image(const int *histogram, int width, int height);

#endif // HISTOGRAM_H// END OF FILE: include/analysis/histogram.h

//---> PATH: /home/atabong/Documents/projet/imgproc/include/analysis/stats.h

#ifndef STATS_H
#define STATS_H

#include "core/image.h" // On a besoin de la d√©finition de la structure Image

/**
 * @brief Calcule la luminance (moyenne) d'une image en niveaux de gris.
 *
 * @param img L'image source.
 * @return La luminance de l'image, ou -1 en cas d'erreur.
 */
double calculate_luminance(const Image *img);

/**
 * @brief Calcule le contraste d'une image en niveaux de gris.
 *
 *  Utilise la formule : contraste = (max - min) / (max + min)
 * @param img L'image source.
 * @return Le contraste de l'image, ou -1 en cas d'erreur.
 */
double calculate_contrast(const Image *img);

#endif// END OF FILE: include/analysis/stats.h

//---> PATH: /home/atabong/Documents/projet/imgproc/include/cli/parser.h

#ifndef PARSER_H
#define PARSER_H

#include <stdbool.h> // Pour le type bool√©en
//  ... vos autres includes
#include "filters/pointwise.h" // Pour les transformations
#include "analysis/stats.h" // pour calculer la luminance et le contraste
#include "fft/fft.h"


// D√©claration de la structure qui contiendra tous les arguments pars√©s.
// Elle est ici pour que main.c sache √† quoi ressemble le type "Arguments".
typedef struct {
    const char *input_path;
    const char *output_path;
    bool show_histogram;
    bool show_luminance;
    bool show_contrast;
    double linear_gain;
    double linear_bias;
    int saturated_min;
    int saturated_max;
    const char *histogram_output_path;
    int blur_kernel_size;
    int gaussian_blur_kernel_size;
    bool apply_sobel;
    bool apply_sharpen;
    bool apply_equalization;
    int median_kernel_size;
    bool test_fft;
    const char *fft_spectrum_path;
    int fft_lowpass_radius;  
    int fft_highpass_radius;
    bool apply_prewitt;    
    bool apply_roberts;    
    int threshold_value;  
    NotchFilter notches[10]; 
    int notch_count;
    int auto_notch_radius;  
    
} Arguments;

/**
 * @brief Analyse les arguments de la ligne de commande.
 *
 * @param argc Le nombre d'arguments (venant de main).
 * @param argv Le tableau d'arguments (venant de main).
 * @return Une structure Arguments remplie avec les valeurs pars√©es.
 *         Le programme se termine avec une erreur si les arguments obligatoires
 *         sont manquants.
 */
Arguments parse_args(int argc, char *argv[]);





#endif // PARSER_H// END OF FILE: include/cli/parser.h

//---> PATH: /home/atabong/Documents/projet/imgproc/include/core/image.h

#ifndef IMAGE_H
#define IMAGE_H

#include <stdint.h> // Pour utiliser des types d'entiers explicites comme uint8_t

/**
 * @struct Image
 * @brief Repr√©sente une image en m√©moire.
 *
 * L'image est stock√©e comme un tableau 1D de pixels (data).
 * Le nombre de canaux (channels) d√©termine la nature de l'image :
 *  - 1: Niveaux de gris
 *  - 3: Couleur (RVB)
 */
typedef struct {
    int width;      // Largeur de l'image en pixels
    int height;     // Hauteur de l'image en pixels
    int channels;   // Nombre de canaux par pixel (1 pour gris, 3 pour RVB)
    uint8_t *data;  // Pointeur vers le buffer contenant les donn√©es des pixels
} Image;

/**
 * @brief Alloue de la m√©moire pour une nouvelle image.
 *
 * @param width La largeur de l'image.
 * @param height La hauteur de l'image.
 * @param channels Le nombre de canaux par pixel.
 * @return Un pointeur vers la nouvelle structure Image, ou NULL en cas d'√©chec d'allocation.
 */
Image *createImage(int width, int height, int channels);

/**
 * @brief Lib√®re la m√©moire allou√©e pour une image.
 *
 * @param img Pointeur vers l'image √† lib√©rer.
 */
void freeImage(Image *img);

#endif // IMAGE_H// END OF FILE: include/core/image.h

//---> PATH: /home/atabong/Documents/projet/imgproc/include/fft/complex.h

#ifndef COMPLEX_H
#define COMPLEX_H

// Notre structure pour repr√©senter un nombre complexe z = a + ib
typedef struct {
    double real; // Partie r√©elle (a)
    double imag; // Partie imaginaire (b)
} Complex;

// Fonctions utilitaires pour l'arithm√©tique des nombres complexes
Complex complex_add(Complex a, Complex b);
Complex complex_sub(Complex a, Complex b);
Complex complex_mul(Complex a, Complex b);
double complex_magnitude(Complex c);

#endif // COMPLEX_H// END OF FILE: include/fft/complex.h

//---> PATH: /home/atabong/Documents/projet/imgproc/include/fft/fft.h

#ifndef FFT_H
#define FFT_H

#include "core/image.h"
#include "fft/complex.h"

// Structure pour un seul filtre notch
typedef struct {
    int u;
    int v;
    int radius;
} NotchFilter;

/**
 * @brief Calcule la Transform√©e de Fourier Rapide (FFT) 2D d'une image.
 *
 * L'image d'entr√©e est d'abord convertie en une matrice de nombres complexes
 * et potentiellement agrandie (padding) pour que ses dimensions soient des
 * puissances de 2, condition n√©cessaire pour l'algorithme FFT.
 *
 * @param src L'image source en niveaux de gris.
 * @param out_width Pointeur pour stocker la largeur de la matrice de sortie.
 * @param out_height Pointeur pour stocker la hauteur de la matrice de sortie.
 * @return Une matrice 2D de nombres complexes allou√©e dynamiquement, ou NULL en cas d'erreur.
 *         L'appelant est responsable de lib√©rer cette m√©moire avec free_fft_data().
 */
Complex **fft2d(const Image *src, int *out_width, int *out_height);

/**
 * @brief Calcule la FFT 2D Inverse pour revenir au domaine spatial.
 *
 * @param fft_data La matrice de nombres complexes.
 * @param width La largeur de la matrice.
 * @param height La hauteur de la matrice.
 * @return Une nouvelle image en niveaux de gris, ou NULL en cas d'erreur.
 */
Image *ifft2d(Complex **fft_data, int width, int height);

/**
 * @brief Lib√®re la m√©moire allou√©e pour une matrice de donn√©es FFT.
 *
 * @param data La matrice √† lib√©rer.
 * @param height La hauteur de la matrice.
 */
void free_fft_data(Complex **data, int height);

/**
 * @brief Cr√©e une image visible du spectre de magnitude de la FFT.
 *
 * Le spectre est d√©cal√© pour centrer les basses fr√©quences et mis √† l'√©chelle
 * de mani√®re logarithmique pour une meilleure visualisation.
 *
 * @param fft_data La matrice de nombres complexes issue de fft2d.
 * @param width La largeur de la matrice.
 * @param height La hauteur de la matrice.
 * @return Une nouvelle image PGM repr√©sentant le spectre, ou NULL en cas d'erreur.
 */
Image *create_spectrum_image(Complex **fft_data, int width, int height);


/**
 * @brief Applique un filtre passe-bas id√©al dans le domaine fr√©quentiel.
 *
 * Ce filtre supprime toutes les fr√©quences au-del√† d'un certain rayon,
 * produisant un effet de flou.
 *
 * @param fft_data La matrice de nombres complexes (sera modifi√©e en place).
 * @param width La largeur de la matrice.
 * @param height La hauteur de la matrice.
 * @param radius Le rayon de coupure (en pixels). Les fr√©quences √† l'ext√©rieur
 *               de ce rayon seront mises √† z√©ro.
 */
void fft_lowpass_filter(Complex **fft_data, int width, int height, int radius);

/**
 * @brief Applique un filtre passe-haut id√©al dans le domaine fr√©quentiel.
 *
 * Ce filtre supprime toutes les fr√©quences en de√ß√† d'un certain rayon,
 * ne conservant que les d√©tails et les contours.
 *
 * @param fft_data La matrice de nombres complexes (sera modifi√©e en place).
 * @param width La largeur de la matrice.
 * @param height La hauteur de la matrice.
 * @param radius Le rayon de coupure (en pixels). Les fr√©quences √† l'int√©rieur
 *               de ce rayon seront mises √† z√©ro.
 */
void fft_highpass_filter(Complex **fft_data, int width, int height, int radius);


void fft_notch_filter(Complex **fft_data, int width, int height, int u, int v, int radius);

/**
 * @brief Applique un filtre coupe-bande automatique pour supprimer le bruit p√©riodique.
 *
 * Analyse le spectre pour d√©tecter les pics de bruit (points brillants isol√©s)
 * et applique automatiquement des filtres notch pour les supprimer.
 *
 * @param fft_data La matrice de nombres complexes (sera modifi√©e en place).
 * @param width La largeur de la matrice.
 * @param height La hauteur de la matrice.
 * @param threshold_factor Facteur de seuil. Un pic est consid√©r√© comme du bruit s'il est
 *                         'threshold_factor' fois plus brillant que la m√©diane du spectre.
 *                         Une valeur typique est 10.0.
 * @param radius Le rayon des filtres notch √† appliquer.
 * @return Le nombre de paires de pics de bruit d√©tect√©es et supprim√©es.
 */
int fft_auto_notch_filter(Complex **fft_data, int width, int height, double threshold_factor, int radius);


#endif // FFT_H// END OF FILE: include/fft/fft.h

//---> PATH: /home/atabong/Documents/projet/imgproc/include/filters/convolution.h

#ifndef CONVOLUTION_H
#define CONVOLUTION_H

#include "core/image.h"

/**
 * @struct Kernel
 * @brief Repr√©sente un noyau (ou masque) de convolution.
 *
 * Le noyau est une petite matrice (ex: 3x3, 5x5) qui est appliqu√©e √† chaque pixel de l'image.
 * La somme des coefficients du noyau est stock√©e dans 'factor' pour la normalisation.
 */
typedef struct {
    int width;      // Largeur du noyau (g√©n√©ralement un nombre impair)
    int height;     // Hauteur du noyau (g√©n√©ralement un nombre impair)
    float *data;    // Pointeur vers les coefficients du noyau (tableau 1D)
} Kernel;

/**
 * @brief Applique une convolution sur une image.
 *
 * Cr√©e une nouvelle image pour stocker le r√©sultat de la convolution.
 *
 * @param src L'image source (ne sera pas modifi√©e).
 * @param kernel Le noyau de convolution √† appliquer.
 * @return Un pointeur vers une nouvelle Image contenant le r√©sultat,
 *         ou NULL en cas d'erreur.
 */
Image *apply_convolution(const Image *src, const Kernel *kernel);

#endif // CONVOLUTION_H// END OF FILE: include/filters/convolution.h

//---> PATH: /home/atabong/Documents/projet/imgproc/include/filters/histogram_equalization.h

#ifndef HISTOGRAM_EQUALIZATION_H
#define HISTOGRAM_EQUALIZATION_H

#include "core/image.h"

/**
 * @brief Applique une √©galisation d'histogramme globale sur une image.
 *
 * Cette transformation redistribue les intensit√©s des pixels pour
 * √©taler l'histogramme et am√©liorer le contraste global.
 *
 * @param src L'image source (ne sera pas modifi√©e).
 * @return Une nouvelle image avec son histogramme √©galis√©, ou NULL en cas d'erreur.
 */
Image *equalize_histogram(const Image *src);

#endif // HISTOGRAM_EQUALIZATION_H// END OF FILE: include/filters/histogram_equalization.h

//---> PATH: /home/atabong/Documents/projet/imgproc/include/filters/pointwise.h

#ifndef POINTWISE_H
#define POINTWISE_H

#include "core/image.h"

/**
 * @brief Applique une transformation lin√©aire √† une image en niveaux de gris.
 *
 * I' = a * I + b
 *  o√π I est le pixel original, I' est le pixel transform√©,
 * a est le gain (multiplier), et b est le biais (offset).
 *
 * @param img L'image source.
 * @param a Le facteur de gain.
 * @param b Le facteur de biais.
 */
void linear_transform(Image *img, double a, double b);

/**
 * @brief Applique une transformation lin√©aire avec saturation.
 *
 * Les pixels en dehors des seuils min/max sont √©cr√™t√©s.
 *
 * @param img L'image source.
 * @param min_in Le niveau de gris d'entr√©e qui correspond √† 0 en sortie.
 * @param max_in Le niveau de gris d'entr√©e qui correspond √† 255 en sortie.
 */
void saturated_transform(Image *img, int min_in, int max_in);


/**
 * @brief Applique un seuillage binaire √† une image.
 *
 * Tous les pixels avec une valeur inf√©rieure au seuil sont mis √† 0 (noir),
 * les autres sont mis √† 255 (blanc). L'op√©ration est faite en place.
 *
 * @param img L'image √† modifier.
 * @param threshold La valeur de seuil (entre 0 et 255).
 */
void apply_threshold(Image *img, uint8_t threshold);

#endif // POINTWISE_H// END OF FILE: include/filters/pointwise.h

//---> PATH: /home/atabong/Documents/projet/imgproc/include/filters/predefined_filters.h

#ifndef PREDEFINED_FILTERS_H
#define PREDEFINED_FILTERS_H

#include "core/image.h"

/**
 * @brief Applique un filtre de flou moyenneur √† une image.
 *
 * @param src L'image source.
 * @param kernel_size La taille du noyau (ex: 3 pour un noyau 3x3, 5 pour 5x5).
 *                    Doit √™tre un nombre impair.
 * @return Une nouvelle image flout√©e, ou NULL en cas d'erreur.
 */
Image *apply_box_blur(const Image *src, int kernel_size);

/**
 * @brief Applique un filtre de flou Gaussien √† une image.
 *
 * @param src L'image source.
 * @param kernel_size La taille du noyau (ex: 3, 5). Doit √™tre un nombre impair.
 * @return Une nouvelle image avec flou Gaussien, ou NULL en cas d'erreur.
 */
Image *apply_gaussian_blur(const Image *src, int kernel_size);

/**
 * @brief Applique le filtre de Sobel pour la d√©tection de contours.
 *
 * @param src L'image source.
 * @return Une nouvelle image montrant les contours, ou NULL en cas d'erreur.
 */
Image *apply_sobel_filter(const Image *src);

/**
 * @brief Applique un filtre de rehaussement de contours (nettet√©).
 *
 * Ce filtre utilise un noyau Laplacien pour trouver les contours
 * et les soustrait de l'image originale pour les assombrir.
 *
 * @param src L'image source.
 * @return Une nouvelle image avec les contours rehauss√©s, ou NULL en cas d'erreur.
 */
Image *apply_sharpen_filter(const Image *src);

/**
 * @brief Applique un filtre m√©dian √† une image.
 *
 * Filtre non-lin√©aire tr√®s efficace pour supprimer le bruit de type "poivre et sel".
 * Il remplace chaque pixel par la valeur m√©diane de son voisinage.
 *
 * @param src L'image source (ne sera pas modifi√©e).
 * @param kernel_size La taille du voisinage (ex: 3 pour 3x3). Doit √™tre un nombre impair.
 * @return Une nouvelle image filtr√©e, ou NULL en cas d'erreur.
 */
Image *apply_median_filter(const Image *src, int kernel_size);

/**
 * @brief Applique le filtre de Prewitt pour la d√©tection de contours.
 *
 * @param src L'image source.
 * @return Une nouvelle image montrant les contours, ou NULL en cas d'erreur.
 */
Image *apply_prewitt_filter(const Image *src);

/**
 * @brief Applique le filtre de Roberts pour la d√©tection de contours.
 *
 * @param src L'image source.
 * @return Une nouvelle image montrant les contours, ou NULL en cas d'erreur.
 */
Image *apply_roberts_filter(const Image *src);


#endif // PREDEFINED_FILTERS_H// END OF FILE: include/filters/predefined_filters.h

//---> PATH: /home/atabong/Documents/projet/imgproc/include/io/pnm.h

#ifndef PNM_H
#define PNM_H

#include "core/image.h" // On a besoin de la d√©finition de la structure Image

/**
 * @brief Charge une image depuis un fichier au format PPM (P6) ou PGM (P5).
 *
 * @param filename Le chemin du fichier √† charger.
 * @return Un pointeur vers une nouvelle structure Image contenant les donn√©es,
 *         ou NULL en cas d'erreur (fichier non trouv√©, format invalide, etc.).
 */
Image *loadPNM(const char *filename);

/**
 * @brief Sauvegarde une image dans un fichier au format PPM (P6) ou PGM (P5).
 *
 * Le format est choisi automatiquement en fonction du nombre de canaux de l'image.
 * @param img Pointeur vers l'image √† sauvegarder.
 * @param filename Le chemin du fichier de destination.
 * @return 0 en cas de succ√®s, -1 en cas d'erreur.
 */
int savePNM(const Image *img, const char *filename);

#endif // PNM_H// END OF FILE: include/io/pnm.h

//---> PATH: /home/atabong/Documents/projet/imgproc/Makefile

# Nom de l'ex√©cutable final
TARGET = imgproc

# R√©pertoire de sortie pour l'ex√©cutable
BIN_DIR = bin

# Ex√©cutable final avec son chemin
TARGET_EXEC = $(BIN_DIR)/$(TARGET)

# Compilateur
CC = gcc

# Options de compilation :
# -Wall -Wextra : Active tous les avertissements utiles. Indispensable.
# -g : Inclut les informations de d√©bogage (pour gdb).
# -std=c99 : Sp√©cifie la norme du langage C.
# -Iinclude : Dit au compilateur de chercher les fichiers .h dans le dossier 'include'.
CFLAGS = -Wall -Wextra -g -std=gnu99 -Iinclude 

# R√©pertoire des sources
SRC_DIR = src

# R√©pertoire des fichiers objets
BUILD_DIR = build

# Trouve automatiquement tous les fichiers .c dans src et ses sous-dossiers
SRCS = $(shell find $(SRC_DIR) -name '*.c')

# G√©n√®re les noms des fichiers objets correspondants dans le dossier 'build'
OBJS = $(patsubst $(SRC_DIR)/%.c, $(BUILD_DIR)/%.o, $(SRCS))

# R√®gle principale : ce qui est ex√©cut√© quand on tape 'make'
all: $(TARGET_EXEC)

# R√®gle pour lier les fichiers objets et cr√©er l'ex√©cutable final
$(TARGET_EXEC): $(OBJS)
	@mkdir -p $(BIN_DIR) # Cr√©e le dossier bin s'il n'existe pas
	$(CC) $(OBJS) -o $@ -lm

# R√®gle pour compiler les fichiers sources .c en fichiers objets .o
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.c
	@mkdir -p $(@D) # Cr√©e le sous-dossier dans 'build' s'il n'existe pas
	$(CC) $(CFLAGS) -c $< -o $@

# R√®gle pour nettoyer le projet
clean:
	@echo "Nettoyage du projet..."
	rm -rf $(BUILD_DIR) $(BIN_DIR)

# R√®gle pour ex√©cuter le programme
run: all
	./$(TARGET_EXEC)

// END OF FILE: Makefile

//---> PATH: /home/atabong/Documents/projet/imgproc/prompter.sh

#!/bin/bash

# --- Configuration ---

# Default project path if none provided
DEFAULT_PROJECT_PATH="."
PROJECT_PATH=${1:-"$DEFAULT_PROJECT_PATH"}

# Output file name (relative to PROJECT_PATH)
OUTPUT_FILENAME="project_context.txt"

# Directories to completely ignore (won't be traversed)
EXCLUDE_DIRS_PATTERN=( \
    ".*"            # All hidden folders (.git, .vscode, .idea, .svn, etc.)
    "node_modules"
    "vendor"        # PHP Composer
    "build"
    "dist"
    "target"        # Java/Rust build outputs
    "__pycache__"   # Python cache
    ".next"         # Next.js build output
    "cache"         # General cache folders
    "target"
    "venv"
    "storage"       # Laravel storage (often contains logs, cache, etc.)
    # Add more directory names here if needed
)

# Specific file patterns to ignore within traversed directories
EXCLUDE_FILES_PATTERN=( \
    "*.log"
    "*.jar"
    "*.pdf"
    "*.png"
    "*.jpg"
    "*.class"
    "*.sqlite"
    "*.csv"
    "project_context.txt"
    # ".env*"       # Consider if you NEED .env files; uncomment if NOT needed.
    "package-lock.json"
    "yarn.lock"
    "composer.lock"
    "*.ico"
    "pnpm-lock.yaml"
    # Add more file patterns here (e.g., "*.swp", "*.bak", "*.tmp")
)

# --- Script Logic ---

# Attempt to get absolute path; exit if PROJECT_PATH is invalid early
PROJECT_PATH=$(realpath "$PROJECT_PATH" 2>/dev/null)
if [ $? -ne 0 ] || [ ! -d "$PROJECT_PATH" ]; then
    echo "Error: Invalid or non-existent project directory specified." >&2 # Error to stderr
    exit 1
fi

OUTPUT_FILE="$PROJECT_PATH/$OUTPUT_FILENAME"

# --- Safety Check: Prevent overwriting the project directory itself ---
# This is unlikely but guards against strange configurations
if [ "$PROJECT_PATH" == "$OUTPUT_FILE" ]; then
    echo "Error: Project directory path conflicts with output file name '$OUTPUT_FILENAME'." >&2
    exit 1
fi

# Delete output file silently if it exists
rm -f "$OUTPUT_FILE"

# --- Build the find command ---
# Uses arrays to construct the find command safely and avoid complex escaping issues with eval
find_args=("$PROJECT_PATH")

# Add directory prune conditions
if [ ${#EXCLUDE_DIRS_PATTERN[@]} -gt 0 ]; then
    find_args+=(\()
    first_prune=true
    for dir_pattern in "${EXCLUDE_DIRS_PATTERN[@]}"; do
        if ! $first_prune; then
            find_args+=(-o)
        fi
        find_args+=(-name "$dir_pattern" -type d)
        first_prune=false
    done
    find_args+=(\) -prune -o) # Add the prune action and the OR for the next part
fi

# Add primary find conditions (type file, exclude output file, exclude patterns)
find_args+=(\( -type f -not -path "$OUTPUT_FILE")
if [ ${#EXCLUDE_FILES_PATTERN[@]} -gt 0 ]; then
    for file_pattern in "${EXCLUDE_FILES_PATTERN[@]}"; do
        find_args+=(-not -name "$file_pattern")
    done
fi
find_args+=(-print \)) # Add the print action and close the group

# --- Execute the find command and process results ---

# Create the header in the output file
{
    echo "Project Context From: $PROJECT_PATH"
    echo "Generated On: $(date)"
    echo "==============================================="
    echo "Ignored Directory Patterns: ${EXCLUDE_DIRS_PATTERN[*]}"
    echo "Ignored File Patterns: ${EXCLUDE_FILES_PATTERN[*]}"
    echo "==============================================="
    echo ""
} > "$OUTPUT_FILE"

error_count=0
# Use find with process substitution and sorting. Avoids eval.
while IFS= read -r FILE_PATH; do
    # Calculate relative path for cleaner output
    RELATIVE_PATH="${FILE_PATH#"$PROJECT_PATH"/}"

    # Append file info and content to the output file
    {
        # echo ""
        # echo "// ==============================================="
        # echo "---> FILE: $RELATIVE_PATH"
        echo "//---> PATH: $FILE_PATH"
        # echo "// ==============================================="
        echo ""
    } >> "$OUTPUT_FILE"

    # Check if file is likely binary/non-text using 'file' command
    # -b: omit filename; check for common non-text types
    if file -b "$FILE_PATH" | grep -q -E 'binary|archive|compressed|image|font'; then
        echo "[Non-text file (e.g., binary, data, compressed) - Contents omitted]" >> "$OUTPUT_FILE"
    else
        # Append text file content, redirect cat errors to stderr
        if ! cat "$FILE_PATH" >> "$OUTPUT_FILE" 2> /dev/null; then # Hide cat errors from stdout
             # Optionally log error to the output file itself, or just count it
             echo "[Error reading file content for $RELATIVE_PATH]" >> "$OUTPUT_FILE"
             ((error_count++))
        fi
    fi

    {
        # echo ""
        echo "// END OF FILE: $RELATIVE_PATH"
        echo ""
    } >> "$OUTPUT_FILE"

done < <(find "${find_args[@]}" | sort) # Execute find command using safe array expansion

# Optionally report errors to stderr if any occurred
if [ $error_count -gt 0 ]; then
    echo "Warning: Encountered $error_count errors reading file contents during context generation." >&2
    # Exit with a non-zero status to indicate partial success/warning
    exit 1
fi

# Exit silently on success
exit 0
// END OF FILE: prompter.sh

//---> PATH: /home/atabong/Documents/projet/imgproc/readme.md

# imgproc - Bo√Æte √† Outils de Traitement d'Image en C

![Version](https://img.shields.io/badge/version-1.0.0-blue)
![Langage](<https://img.shields.io/badge/langage-C_(gnu99)-brightgreen>)
![Licence](https://img.shields.io/badge/licence-MIT-orange)

## üìñ Table des Mati√®res

1.  [Introduction](#-introduction)
2.  [Fonctionnalit√©s](#-fonctionnalit√©s)
    - [Fonctionnalit√©s Impl√©ment√©es](#-fonctionnalit√©s-impl√©ment√©es)
    - [Fonctionnalit√©s Pr√©vues](#-fonctionnalit√©s-pr√©vues)
3.  [Compilation et Installation](#-compilation-et-installation)
4.  [Guide d'Utilisation](#-guide-dutilisation)
    - [Syntaxe G√©n√©rale](#syntaxe-g√©n√©rale)
    - [Analyse d'Image](#analyse-dimage)
    - [Transformations Ponctuelles](#transformations-ponctuelles-correction-des-couleurs-et-du-contraste)
    - [Filtrage par Convolution](#filtrage-par-convolution-flou-nettet√©-d√©tection-de-contours)
    - [Am√©lioration d'Histogramme](#am√©lioration-dhistogramme)
    - [Cha√Ænage des Op√©rations](#cha√Ænage-des-op√©rations)
5.  [Architecture du Projet](#-architecture-du-projet)
6.  [Comment Contribuer](#-comment-contribuer)

---

## üåü Introduction

**imgproc** est un programme en ligne de commande (CLI) d√©velopp√© en C pur pour le traitement d'images. Con√ßu pour √™tre l√©ger, performant et hautement modulaire, il offre une large gamme d'op√©rations allant de l'analyse d'image aux transformations g√©om√©triques, en passant par le filtrage spatial avanc√© via la convolution.

Ce projet met l'accent sur la clart√© du code, la robustesse des algorithmes et une gestion rigoureuse de la m√©moire. Il ne repose sur aucune biblioth√®que de traitement d'image externe, tous les algorithmes √©tant impl√©ment√©s "from scratch".

Les formats d'image support√©s pour l'instant sont le **PPM (couleur)** et le **PGM (niveaux de gris)**, en version binaire (P6/P5).

---

## ‚ú® Fonctionnalit√©s

### ‚úÖ Fonctionnalit√©s Impl√©ment√©es

| Cat√©gorie                   | Fonctionnalit√©                          | Description                                                                                                                            |
| --------------------------- | --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| **I/O**                     | Lecture/√âcriture PPM/PGM                | Chargement et sauvegarde d'images aux formats PGM (P5, binaire) et PPM (P6, binaire).                                                  |
| **Analyse**                 | Calcul de Luminance                     | Calcule la valeur moyenne des pixels de l'image (intensit√© lumineuse globale).                                                         |
| **Analyse**                 | Calcul de Contraste                     | Calcule le contraste de l'image en se basant sur la variation entre les niveaux de gris minimum et maximum.                            |
| **Analyse**                 | G√©n√©ration d'Histogramme                | Calcule la distribution des niveaux de gris et peut g√©n√©rer une image PGM repr√©sentant visuellement cet histogramme.                   |
| **Transformations**         | Transformation Lin√©aire                 | Modifie la luminosit√© et le contraste en appliquant une fonction `I' = a*I + b` √† chaque pixel.                                        |
| **Transformations**         | Transformation Lin√©aire avec Saturation | Augmente le contraste en √©tirant une plage de niveaux de gris sp√©cifi√©e sur toute la dynamique (0-255).                                |
| **Transformations**         | Seuillage Binaire (Thresholding)        | Convertit une image en niveaux de gris en une image binaire (noir et blanc) en fonction d'une valeur de seuil.                         |
| **Am√©lioration**            | √âgalisation d'Histogramme               | Transformation non-lin√©aire qui redistribue les intensit√©s pour maximiser le contraste global. Tr√®s efficace sur les images ternes.    |
| **Filtrage (Convolution)**  | Moteur de Convolution G√©n√©rique         | Un moteur robuste capable d'appliquer n'importe quel noyau de convolution (masque) √† une image. G√®re les bords par r√©plication.        |
| **Filtrage (Convolution)**  | Flou Moyenneur (Box Blur)               | Lisse l'image et r√©duit le bruit en rempla√ßant chaque pixel par la moyenne de ses voisins. La force du flou est param√©trable.          |
| **Filtrage (Convolution)**  | Flou Gaussien                           | Applique un flou plus naturel et de meilleure qualit√© que le flou moyenneur, en donnant plus de poids aux pixels centraux.             |
| **Filtrage (Convolution)**  | D√©tection de Contours (Sobel)           | Met en √©vidence les contours de l'image en calculant le gradient d'intensit√©.                                                          |
| **Filtrage (Convolution)**  | Rehaussement de Nettet√© (Sharpen)       | Augmente la nettet√© per√ßue de l'image en assombrissant les bords des contours, les rendant plus "tranch√©s".                            |
| **Filtrage (Convolution)**  | D√©tection de Contours (Prewitt)         | Alternative √† Sobel pour la d√©tection de contours, bas√©e sur la d√©riv√©e premi√®re.                                                      |
| **Filtrage (Convolution)**  | D√©tection de Contours (Roberts)         | Un des premiers op√©rateurs de d√©tection de contours, utilisant un noyau 2x2.                                                           |
| **Filtrage (Non-lin√©aire)** | Filtre M√©dian                           | Supprime efficacement le bruit "poivre et sel" en pr√©servant les contours, en rempla√ßant chaque pixel par la m√©diane de son voisinage. |
| **Domaine Fr√©quentiel**     | Visualisation du Spectre de Fourier     | Calcule la Transform√©e de Fourier 2D et g√©n√®re une image de son spectre de magnitude, avec les basses fr√©quences centr√©es.             |
| **Domaine Fr√©quentiel**     | Filtre Passe-Bas Fr√©quentiel            | Applique un flou puissant en supprimant les hautes fr√©quences de l'image via une multiplication dans le domaine de Fourier.            |
| **Domaine Fr√©quentiel**     | Filtre Passe-Haut Fr√©quentiel           | Isole les contours et les d√©tails de l'image en supprimant les basses fr√©quences.                                                      |

### üöÄ Fonctionnalit√©s Pr√©vues

| Cat√©gorie                        | Fonctionnalit√©              | Description                                                                                                      |
| -------------------------------- | --------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| **Transformations G√©om√©triques** | Redimensionnement (Scaling) | Changer la taille de l'image en utilisant des algorithmes d'interpolation (Plus Proche Voisin, Bilin√©aire).      |
| **Transformations G√©om√©triques** | Rotation                    | Faire pivoter une image de 90, 180 ou 270 degr√©s.                                                                |
| **Transformations G√©om√©triques** | Sym√©trie (Flip)             | Appliquer un effet miroir horizontal ou vertical √† l'image.                                                      |
| **Exp√©rience Utilisateur**       | Assistant Interactif        | Un mode menu en console pour guider les utilisateurs √† travers les fonctionnalit√©s sans m√©moriser les commandes. |
| **I/O**                          | Support du format BMP       | Ajouter la capacit√© de lire et √©crire des images au format BMP 24-bits non compress√©.                            |
| **Qualit√©**                      | Tests Unitaires Automatis√©s | Mise en place d'un framework de tests pour valider le comportement des fonctions et √©viter les r√©gressions.      |

---

## üõ†Ô∏è Compilation et Installation

Ce projet utilise `make` pour la compilation. Assurez-vous d'avoir `gcc` et `make` install√©s sur votre syst√®me.

1.  **Clonez le d√©p√¥t :**

    ```bash
    git clone https://votre-url-de-depot/imgproc.git
    cd imgproc
    ```

2.  **Compilez le projet :**
    Ex√©cutez `make` √† la racine du projet.

    ```bash
    make
    ```

    Cette commande va compiler tous les fichiers source `.c` du r√©pertoire `src/` et placer l'ex√©cutable final dans `bin/imgproc`.

3.  **Nettoyer le projet :**
    Pour supprimer tous les fichiers g√©n√©r√©s (objets et ex√©cutable), utilisez la commande :
    ```bash
    make clean
    ```

## üñ•Ô∏è Guide d'Utilisation

### Syntaxe G√©n√©rale

La structure d'une commande `imgproc` est la suivante :

```bash
./bin/imgproc --input <fichier_entree> --output <fichier_sortie> [options...]
```

- `--input <path>` : **(Obligatoire)** Sp√©cifie le chemin vers l'image √† traiter.
- `--output <path>` : **(Obligatoire)** Sp√©cifie le chemin o√π sauvegarder l'image r√©sultante.

Les op√©rations sont appliqu√©es dans un ordre logique pr√©d√©fini, quel que soit l'ordre des options dans la commande.

### Analyse d'Image

Ces options affichent des informations dans la console ou g√©n√®rent des fichiers d'analyse.

- `--luminance` : Calcule et affiche la luminance moyenne de l'image.

  ```bash
  ./bin/imgproc --input image.pgm --output out.pgm --luminance
  ```

- `--contrast` : Calcule et affiche le contraste de l'image.

  ```bash
  ./bin/imgproc --input image.pgm --output out.pgm --contrast
  ```

- `--histogram <path_hist.pgm>` : Calcule l'histogramme de l'image et le sauvegarde sous forme d'une image PGM.
  ```bash
  ./bin/imgproc --input photo.pgm --output out.pgm --histogram histogramme.pgm
  ```

### Transformations Ponctuelles (Correction des couleurs et du contraste)

- `--linear <gain> <biais>` : Applique une transformation lin√©aire `I' = gain * I + biais`. Utile pour ajuster manuellement la luminosit√© et le contraste.

  ```bash
  # Augmente le contraste (gain > 1) et assombrit l√©g√®rement l'image (biais < 0)
  ./bin/imgproc --input image.pgm --output out.pgm --linear 1.5 -20
  ```

- `--saturate <min> <max>` : √âtire les niveaux de gris compris entre `<min>` et `<max>` sur toute la plage 0-255. Les valeurs en dehors de cet intervalle sont "satur√©es" (mises √† 0 ou 255).

  ```bash
  # Se concentre sur les niveaux de gris entre 50 et 200 pour maximiser le contraste
  ./bin/imgproc --input image.pgm --output out.pgm --saturate 50 200
  ```

- `--threshold <valeur>` : Applique un seuillage binaire. `<valeur>` est un entier de 0 √† 255. Tr√®s utile apr√®s un filtre de d√©tection de contours.

  ```bash
  # D√©tecter les contours avec Sobel puis les nettoyer avec un seuil
  ./bin/imgproc --input image.pgm --output contours_propres.pgm --sobel --threshold 50
  ```

### Filtrage par Convolution (Flou, Nettet√©, D√©tection de contours)

- `--blur <taille>` : Applique un flou moyenneur. `<taille>` doit √™tre un entier impair (ex: 3, 5, 9). Plus la taille est grande, plus le flou est prononc√©.

  ```bash
  ./bin/imgproc --input image.pgm --output out.pgm --blur 5
  ```

- `--gaussian-blur <taille>` : Applique un flou Gaussien, plus doux et de meilleure qualit√©. `<taille>` doit √™tre un entier impair.

  ```bash
  ./bin/imgproc --input image.pgm --output out.pgm --gaussian-blur 5
  ```

- `--sobel` : Applique le filtre de Sobel pour d√©tecter les contours. Le r√©sultat est une image en noir et blanc o√π les contours sont mis en √©vidence.

  ```bash
  ./bin/imgproc --input batiment.pgm --output contours.pgm --sobel
  ```

- `--prewitt` : Applique le filtre de Prewitt pour d√©tecter les contours.
- `--roberts` : Applique le filtre de Roberts pour d√©tecter les contours.

- `--sharpen` : Applique un filtre de rehaussement de nettet√©. Il rend les d√©tails et les textures plus "tranch√©s".
  ```bash
  ./bin/imgproc --input portrait.pgm --output portrait_net.pgm --sharpen
  ```
- `--median <taille>` : Applique un filtre m√©dian, tr√®s efficace contre le bruit de type "poivre et sel". `<taille>` doit √™tre un entier impair (typiquement 3 ou 5).
  ```bash
  ./bin/imgproc --input image_bruitee.pgm --output image_propre.pgm --median 3
  ```

### Analyse dans le Domaine Fr√©quentiel

- `--fft-spectrum <path_spectrum.pgm>` : Calcule la Transform√©e de Fourier de l'image et sauvegarde une repr√©sentation visuelle de son spectre dans un fichier PGM.
  ```bash
  # G√©n√©rer le spectre de Fourier de l'image
  ./bin/imgproc --input image.pgm --output out.pgm --fft-spectrum spectre.pgm
  ```
- `--fft-lowpass <rayon>` : Applique un filtre passe-bas id√©al (flou). `<rayon>` d√©finit la taille des basses fr√©quences √† conserver. Une petite valeur (ex: 20) produit un flou tr√®s fort.

  ```bash
  ./bin/imgproc --input image.pgm --output flou.pgm --fft-lowpass 30
  ```

- `--fft-highpass <rayon>` : Applique un filtre passe-haut id√©al (d√©tection de contours). `<rayon>` d√©finit la taille des basses fr√©quences √† supprimer. Une petite valeur (ex: 10) conserve beaucoup de d√©tails.
  ```bash
  ./bin/imgproc --input image.pgm --output contours.pgm --fft-highpass 15
  ```

### Am√©lioration d'Histogramme

- `--equalize` : Applique une √©galisation d'histogramme. C'est la m√©thode la plus puissante pour corriger automatiquement les images sous-expos√©es, sur-expos√©es ou ternes.
  ```bash
  ./bin/imgproc --input photo_sombre.pgm --output photo_corrigee.pgm --equalize
  ```

### Cha√Ænage des Op√©rations

Vous pouvez combiner plusieurs op√©rations en une seule commande. Elles seront appliqu√©es dans un ordre logique (par exemple, le flou avant la d√©tection de contours).

```bash
# Appliquer un l√©ger flou Gaussien pour r√©duire le bruit, puis d√©tecter les contours avec Sobel
./bin/imgproc --input image.pgm --output out.pgm --gaussian-blur 3 --sobel

# Augmenter la nettet√©, puis corriger le contraste global
./bin/imgproc --input image.pgm --output out.pgm --sharpen --equalize
```

---

## üèóÔ∏è Architecture du Projet

Le projet est structur√© de mani√®re modulaire pour garantir la s√©paration des responsabilit√©s, la testabilit√© et l'extensibilit√©.

```
imgproc/
‚îÇ
‚îú‚îÄ‚îÄ bin/              # Contient l'ex√©cutable final
‚îú‚îÄ‚îÄ build/            # Contient les fichiers objets (.o) interm√©diaires
‚îú‚îÄ‚îÄ include/          # Contient les fichiers d'en-t√™te publics (.h)
‚îÇ   ‚îú‚îÄ‚îÄ analysis/     # Headers pour l'analyse (histogramme, stats)
‚îÇ   ‚îú‚îÄ‚îÄ cli/          # Header pour le parseur d'arguments
‚îÇ   ‚îú‚îÄ‚îÄ core/         # Header pour les structures de donn√©es (Image)
‚îÇ   ‚îú‚îÄ‚îÄ filters/      # Headers pour les filtres (convolution, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ io/           # Headers pour la lecture/√©criture de fichiers
‚îú‚îÄ‚îÄ src/              # Contient les fichiers d'impl√©mentation (.c)
‚îÇ   ‚îú‚îÄ‚îÄ analysis/
‚îÇ   ‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ filters/
‚îÇ   ‚îú‚îÄ‚îÄ io/
‚îÇ   ‚îî‚îÄ‚îÄ main.c        # Point d'entr√©e du programme
‚îú‚îÄ‚îÄ tests/            # (Futur) Scripts et donn√©es de test
‚îú‚îÄ‚îÄ Makefile          # G√®re la compilation du projet
‚îî‚îÄ‚îÄ README.md         # Cette documentation
```

Chaque module est con√ßu pour √™tre aussi ind√©pendant que possible :

- Le module `core` ne conna√Æt rien aux formats de fichiers.
- Le module `filters` op√®re sur la structure `Image` sans se soucier de la mani√®re dont elle a √©t√© charg√©e.
- Le module `cli` orchestre les appels aux autres modules en fonction des commandes de l'utilisateur.

---
// END OF FILE: readme.md

//---> PATH: /home/atabong/Documents/projet/imgproc/src/analysis/histogram.c

#include "analysis/histogram.h"
#include <stdio.h> // Pour printf
#include <stdlib.h> // Pour malloc
#include <string.h> // Pour memset

void calculate_histogram(const Image *img, int *histogram) {
    // 1. Initialiser l'histogramme √† z√©ro
    for (int i = 0; i < 256; i++) {
        histogram[i] = 0;
    }

    // 2. Parcourir les pixels de l'image
    if (img != NULL && img->data != NULL) {
        for (int i = 0; i < img->width * img->height; i++) {
            // On suppose que l'image est en niveaux de gris (channels == 1)
            if (img->channels == 1) {
                uint8_t pixel_value = img->data[i];
                histogram[pixel_value]++; // Incr√©menter le compteur du niveau de gris
            }
            // G√©rer les cas o√π les canaux ne sont pas √©gaux √† 1 (ex : 3 pour RVB)
            else if (img->channels == 3){
                uint8_t pixel_value = img->data[i*3]; // Utiliser la composante rouge
                histogram[pixel_value]++; // Incr√©menter le compteur du niveau de gris
            }

             else {
                fprintf(stderr, "calculate_histogram: Nombre de canaux non support√© : %d\n", img->channels);
                return; // Sortir si le nombre de canaux n'est pas g√©r√©.
            }
        }
        printf("Histogramme calcul√© avec succ√®s.\n");
    } else {
        fprintf(stderr, "calculate_histogram: Image invalide (NULL).\n");
    }
}

Image *create_histogram_image(const int *histogram, int width, int height) {
    // 1. Trouver la valeur maximale de l'histogramme pour normaliser les barres
    int max_val = 0;
    for (int i = 0; i < 256; i++) {
        if (histogram[i] > max_val) {
            max_val = histogram[i];
        }
    }

    if (max_val == 0) {
        fprintf(stderr, "create_histogram_image: Histogramme vide, impossible de g√©n√©rer l'image.\n");
        return NULL;
    }

    // 2. Cr√©er une nouvelle image pour l'histogramme (fond blanc)
    Image *hist_img = createImage(width, height, 1); // 1 canal = PGM
    if (!hist_img) {
        return NULL;
    }
    // Remplir l'image de blanc (valeur 255)
    memset(hist_img->data, 255, width * height * sizeof(uint8_t));

    // 3. Dessiner les barres de l'histogramme (en noir)
    double bar_width = (double)width / 256.0;

    for (int i = 0; i < 256; i++) {
        // Calculer la hauteur de la barre normalis√©e
        int bar_height = (int)(((double)histogram[i] / max_val) * (height - 1));

        // D√©terminer les colonnes de l'image pour cette barre
        int start_x = (int)(i * bar_width);
        int end_x = (int)((i + 1) * bar_width);
        if (end_x > width) end_x = width;

        // Dessiner la barre verticale
        for (int x = start_x; x < end_x; x++) {
            for (int y = 0; y < bar_height; y++) {
                // L'origine (0,0) est en haut √† gauche, donc on dessine depuis le bas
                // de l'image (height - 1 - y).
                int pixel_index = (height - 1 - y) * width + x;
                if (pixel_index < width * height) {
                    hist_img->data[pixel_index] = 0; // Pixel noir
                }
            }
        }
    }

    printf("Image de l'histogramme g√©n√©r√©e avec succ√®s.\n");
    return hist_img;
}// END OF FILE: src/analysis/histogram.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/analysis/stats.c

#include "analysis/stats.h"
#include <stdio.h>

double calculate_luminance(const Image *img) {
    if (!img || !img->data) {
        fprintf(stderr, "calculate_luminance: Image invalide.\n");
        return -1.0;
    }

    double sum = 0.0;
    for (int i = 0; i < img->width * img->height * img->channels; i++) {
        sum += img->data[i];
    }

    return sum / (img->width * img->height * img->channels);
}

double calculate_contrast(const Image *img) {
    if (!img || !img->data) {
        fprintf(stderr, "calculate_contrast: Image invalide.\n");
        return -1.0;
    }

    uint8_t min_val = 255;
    uint8_t max_val = 0;

    for (int i = 0; i < img->width * img->height * img->channels; i++) {
         if(img->data[i] < min_val)
             min_val = img->data[i];
        if(img->data[i] > max_val)
            max_val = img->data[i];
    }

    if (max_val == min_val) {
        return 0.0; // Pour √©viter la division par z√©ro si l'image est uniforme
    }

    return (double)(max_val - min_val) / (max_val + min_val);
}// END OF FILE: src/analysis/stats.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/cli/parser.c

#include "cli/parser.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

Arguments parse_args(int argc, char *argv[]) {
    // 1. Initialisation de la structure avec des valeurs par d√©faut.
    // L'initialisation "{0}" met tous les champs √† 0, false, ou NULL.
    Arguments args = {0}; 
    args.linear_gain = 1.0;
    args.linear_bias = 0.0;
    args.saturated_min = -1; // -1 sert de marqueur "non d√©fini"
    args.saturated_max = -1;
    args.blur_kernel_size = 0;
    args.gaussian_blur_kernel_size = 0;
    args.apply_sobel = false;
    args.apply_sharpen = false;
    args.apply_equalization = false;
    args.median_kernel_size = 0;
    args.test_fft = false;
    args.fft_spectrum_path = NULL;
    args.fft_lowpass_radius = 0; 
    args.fft_highpass_radius = 0;
    args.apply_prewitt = false;
    args.apply_roberts = false;
    args.threshold_value = -1;
    args.auto_notch_radius = 0;

    // 2. Boucle sur tous les arguments de la ligne de commande (sauf le nom du programme)
    for (int i = 1; i < argc; i++) {

        // --- Options principales ---
        if (strcmp(argv[i], "--input") == 0) {
            if (i + 1 < argc) {
                args.input_path = argv[++i]; // Consomme la valeur et avance l'index
            } else {
                fprintf(stderr, "Erreur: L'option --input n√©cessite un chemin de fichier.\n");
                exit(1);
            }
        } 
        else if (strcmp(argv[i], "--output") == 0) {
            if (i + 1 < argc) {
                args.output_path = argv[++i]; // Consomme la valeur et avance l'index
            } else {
                fprintf(stderr, "Erreur: L'option --output n√©cessite un chemin de fichier.\n");
                exit(1);
            }
        }

        // --- Options d'analyse ---
        else if (strcmp(argv[i], "--histogram") == 0) {
            // V√©rifie si l'argument suivant existe et n'est pas une autre option
            if (i + 1 < argc && argv[i + 1][0] != '-') {
                args.show_histogram = true; 
                args.histogram_output_path = argv[++i]; // Consomme le chemin du fichier
            } else {
                // Si --histogram est seul, on active un simple bool√©en
                args.show_histogram = true; 
            }
        }
        else if (strcmp(argv[i], "--luminance") == 0) {
            args.show_luminance = true;
        }
        else if (strcmp(argv[i], "--contrast") == 0) {
            args.show_contrast = true;
        }

        // --- Options de transformation ---
        else if (strcmp(argv[i], "--linear") == 0) {
            if (i + 2 < argc) {
                args.linear_gain = atof(argv[++i]); // Consomme le gain
                args.linear_bias = atof(argv[++i]); // Consomme le biais
            } else {
                fprintf(stderr, "Erreur: L'option --linear n√©cessite deux arguments (gain et biais).\n");
                exit(1);
            }
        }
        else if (strcmp(argv[i], "--saturate") == 0) {
            if (i + 2 < argc) {
                args.saturated_min = atoi(argv[++i]); // Consomme le min
                args.saturated_max = atoi(argv[++i]); // Consomme le max
            } else {
                fprintf(stderr, "Erreur: L'option --saturate n√©cessite deux arguments (min et max).\n");
                exit(1);
            }
        }

        else if (strcmp(argv[i], "--blur") == 0) {
            if (i + 1 < argc) {
                args.blur_kernel_size = atoi(argv[++i]);
            } else {
                fprintf(stderr, "Erreur: L'option --blur n√©cessite une taille de noyau (ex: 3).\n");
                exit(1);
            }
        }

        else if (strcmp(argv[i], "--gaussian-blur") == 0) {
            if (i + 1 < argc) {
                args.gaussian_blur_kernel_size = atoi(argv[++i]);
            } else {
                fprintf(stderr, "Erreur: L'option --gaussian-blur n√©cessite une taille.\n");
                exit(1);
            }
        }
        else if (strcmp(argv[i], "--sobel") == 0) {
            args.apply_sobel = true;
        }
        else if (strcmp(argv[i], "--sharpen") == 0) {
            args.apply_sharpen = true;
        }
        else if (strcmp(argv[i], "--equalize") == 0) {
            args.apply_equalization = true;
        }
        else if (strcmp(argv[i], "--equalize") == 0) {
            args.apply_equalization = true;
        }
        else if (strcmp(argv[i], "--median") == 0) {
            if (i + 1 < argc) {
                args.median_kernel_size = atoi(argv[++i]);
            } else {
                fprintf(stderr, "Erreur: L'option --median n√©cessite une taille de noyau (ex: 3).\n");
                exit(1);
            }
        }
        else if (strcmp(argv[i], "--test-fft") == 0) {
            args.test_fft = true;
        }
        else if (strcmp(argv[i], "--test-fft") == 0) {
            args.test_fft = true;
        }
        else if (strcmp(argv[i], "--fft-spectrum") == 0) {
            if (i + 1 < argc) {
                args.fft_spectrum_path = argv[++i];
            } else {
                fprintf(stderr, "Erreur: L'option --fft-spectrum n√©cessite un chemin de fichier de sortie.\n");
                exit(1);
            }
        }
        else if (strcmp(argv[i], "--fft-lowpass") == 0) {
            if (i + 1 < argc) {
                args.fft_lowpass_radius = atoi(argv[++i]);
            } else {
                fprintf(stderr, "Erreur: L'option --fft-lowpass n√©cessite un rayon.\n");
                exit(1);
            }
        }
        else if (strcmp(argv[i], "--fft-highpass") == 0) {
            if (i + 1 < argc) {
                args.fft_highpass_radius = atoi(argv[++i]);
            } else {
                fprintf(stderr, "Erreur: L'option --fft-highpass n√©cessite un rayon.\n");
                exit(1);
            }
        }
        else if (strcmp(argv[i], "--prewitt") == 0) {
            args.apply_prewitt = true;
        }
        else if (strcmp(argv[i], "--roberts") == 0) {
            args.apply_roberts = true;
        }
        else if (strcmp(argv[i], "--threshold") == 0) {
            if (i + 1 < argc) {
                args.threshold_value = atoi(argv[++i]);
            } else {
                fprintf(stderr, "Erreur: L'option --threshold n√©cessite une valeur (0-255).\n");
                exit(1);
            }
        }
        else if (strcmp(argv[i], "--auto-notch") == 0) {
            if (i + 1 < argc) {
                args.auto_notch_radius = atoi(argv[++i]);
            } else {
                fprintf(stderr, "Erreur: L'option --auto-notch n√©cessite un rayon pour les filtres.\n");
                exit(1);
            }
        }


        // --- Gestion des options inconnues ---
        else if (argv[i][0] == '-') {
            // Si l'argument commence par un '-' mais n'a pas √©t√© reconnu par les 'else if' pr√©c√©dents,
            // c'est une option inconnue.
            fprintf(stderr, "Avertissement: Option inconnue ignor√©e : %s\n", argv[i]);
        }
        // Les arguments qui ne commencent pas par '-' sont ignor√©s (car ils sont suppos√©s
        // √™tre des valeurs pour des options, d√©j√† consomm√©es par i++).
    }

    // 3. Validation finale des arguments obligatoires
    if (args.input_path == NULL || args.output_path == NULL) {
        fprintf(stderr, "\nErreur: Les options --input et --output sont obligatoires.\n\n");
        fprintf(stderr, "Usage: %s --input <fichier_entree> --output <fichier_sortie> [options...]\n", argv[0]);
        fprintf(stderr, "Exemple: %s --input in.pgm --output out.pgm --contrast --histogram hist.pgm\n\n", argv[0]);
        exit(1);
    }

    return args;
}// END OF FILE: src/cli/parser.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/core/image.c

#include "core/image.h" // On inclut notre propre header
#include <stdlib.h>     // Pour malloc() et free()
#include <stdio.h>      // Pour perror() en cas d'erreur

Image *createImage(int width, int height, int channels) {
    // 1. Allouer la m√©moire pour la structure Image elle-m√™me
    Image *img = (Image *)malloc(sizeof(Image));
    if (img == NULL) {
        perror("Erreur d'allocation pour la structure Image");
        return NULL;
    }

    // 2. Calculer la taille totale du buffer de pixels
    size_t size = width * height * channels * sizeof(uint8_t);

    // 3. Allouer la m√©moire pour les donn√©es des pixels
    img->data = (uint8_t *)malloc(size);
    if (img->data == NULL) {
        perror("Erreur d'allocation pour les donn√©es de l'image");
        free(img); // Ne pas oublier de lib√©rer la structure si le buffer √©choue !
        return NULL;
    }

    // 4. Initialiser les champs de la structure
    img->width = width;
    img->height = height;
    img->channels = channels;

    return img;
}

void freeImage(Image *img) {
    if (img != NULL) {
        // On lib√®re d'abord le buffer de donn√©es s'il existe
        if (img->data != NULL) {
            free(img->data);
        }
        // Ensuite, on lib√®re la structure elle-m√™me
        free(img);
    }
}// END OF FILE: src/core/image.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/fft/complex.c

#include "fft/complex.h"
#include <math.h>

Complex complex_add(Complex a, Complex b) {
    Complex result = {a.real + b.real, a.imag + b.imag};
    return result;
}

Complex complex_sub(Complex a, Complex b) {
    Complex result = {a.real - b.real, a.imag - b.imag};
    return result;
}

// Multiplication : (a + ib) * (c + id) = (ac - bd) + i(ad + bc)
Complex complex_mul(Complex a, Complex b) {
    Complex result;
    result.real = a.real * b.real - a.imag * b.imag;
    result.imag = a.real * b.imag + a.imag * b.real;
    return result;
}

// Magnitude : |z| = sqrt(a^2 + b^2)
double complex_magnitude(Complex c) {
    return sqrt(c.real * c.real + c.imag * c.imag);
}// END OF FILE: src/fft/complex.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/fft/fft.c

#define _USE_MATH_DEFINES
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "fft/fft.h"
#include <string.h>




// Ajouter cette fonction de comparaison pour qsort (si pas d√©j√† dans ce fichier)
static int compare_doubles(const void *a, const void *b) {
    double val1 = *(const double *)a;
    double val2 = *(const double *)b;
    if (val1 < val2) return -1;
    if (val1 > val2) return 1;
    return 0;
}

// --- Partie 1 : Impl√©mentation de la FFT 1D (Algorithme de Cooley-Tukey) ---

// Fonction interne r√©cursive pour la FFT 1D.
// Op√®re "en place" sur le buffer.
static void _fft1d(Complex *buffer, int n) {
    if (n <= 1) return;

    // Diviser : s√©parer en √©l√©ments pairs et impairs
    Complex *evens = malloc((n / 2) * sizeof(Complex));
    Complex *odds = malloc((n / 2) * sizeof(Complex));
    for (int i = 0; i < n / 2; i++) {
        evens[i] = buffer[i * 2];
        odds[i] = buffer[i * 2 + 1];
    }

    // Conqu√©rir : appels r√©cursifs
    _fft1d(evens, n / 2);
    _fft1d(odds, n / 2);

    // Combiner
    for (int k = 0; k < n / 2; k++) {
        double angle = -2.0 * M_PI * k / n;
        Complex t = {cos(angle), sin(angle)};
        t = complex_mul(t, odds[k]);
        
        buffer[k] = complex_add(evens[k], t);
        buffer[k + n / 2] = complex_sub(evens[k], t);
    }

    free(evens);
    free(odds);
}

// Fonction interne pour la FFT 1D Inverse.
static void _ifft1d(Complex *buffer, int n) {
    // L'IFFT est presque identique √† la FFT.
    // 1. On conjugue les entr√©es.
    for (int i = 0; i < n; i++) {
        buffer[i].imag = -buffer[i].imag;
    }

    // 2. On applique la FFT normale.
    _fft1d(buffer, n);

    // 3. On conjugue le r√©sultat et on le normalise par N.
    for (int i = 0; i < n; i++) {
        buffer[i].imag = -buffer[i].imag;
        buffer[i].real /= n;
        buffer[i].imag /= n;
    }
}

// --- Partie 2 : Fonctions Publiques pour la FFT 2D ---

// Helper pour trouver la prochaine puissance de 2
static int next_power_of_2(int n) {
    int power = 1;
    while (power < n) {
        power *= 2;
    }
    return power;
}

Complex **fft2d(const Image *src, int *out_width, int *out_height) {
    if (!src || !src->data || src->channels != 1) {
        fprintf(stderr, "fft2d: Image invalide ou non support√©e.\n");
        return NULL;
    }

    // Pr√©-traitement : padding pour atteindre des dimensions en puissance de 2
    int width = next_power_of_2(src->width);
    int height = next_power_of_2(src->height);
    *out_width = width;
    *out_height = height;

    // Allocation de la matrice 2D de nombres complexes
    Complex **data = malloc(height * sizeof(Complex *));
    for (int i = 0; i < height; i++) {
        data[i] = calloc(width, sizeof(Complex)); // calloc initialise √† 0
    }

    // Copier les donn√©es de l'image dans la partie r√©elle de la matrice
    for (int y = 0; y < src->height; y++) {
        for (int x = 0; x < src->width; x++) {
            data[y][x].real = src->data[y * src->width + x];
        }
    }

    // FFT sur les lignes
    for (int y = 0; y < height; y++) {
        _fft1d(data[y], width);
    }
    
    // Transposition et FFT sur les colonnes (plus efficace pour le cache)
    // 1. Allouer un buffer temporaire pour une colonne
    Complex *column = malloc(height * sizeof(Complex));
    // 2. Appliquer la FFT colonne par colonne
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            column[y] = data[y][x];
        }
        _fft1d(column, height);
        for (int y = 0; y < height; y++) {
            data[y][x] = column[y];
        }
    }
    free(column);

    return data;
}

Image *ifft2d(Complex **fft_data, int width, int height) {
    // IFFT sur les lignes
    for (int y = 0; y < height; y++) {
        _ifft1d(fft_data[y], width);
    }
    
    // Transposition et IFFT sur les colonnes
    Complex *column = malloc(height * sizeof(Complex));
    for (int x = 0; x < width; x++) {
        for (int y = 0; y < height; y++) {
            column[y] = fft_data[y][x];
        }
        _ifft1d(column, height);
        for (int y = 0; y < height; y++) {
            fft_data[y][x] = column[y];
        }
    }
    free(column);

    // Cr√©er l'image de sortie et copier la partie r√©elle
    Image *dest = createImage(width, height, 1);
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            double val = fft_data[y][x].real;
            if (val < 0) val = 0;
            if (val > 255) val = 255;
            dest->data[y * width + x] = (uint8_t)val;
        }
    }
    return dest;
}

void free_fft_data(Complex **data, int height) {
    if (data) {
        for (int i = 0; i < height; i++) {
            free(data[i]);
        }
        free(data);
    }
}


Image *create_spectrum_image(Complex **fft_data, int width, int height) {
    // 1. Allouer une matrice temporaire pour la magnitude et une image de sortie
    double *magnitude_spectrum = calloc(width * height, sizeof(double));
    Image *spectrum_image = createImage(width, height, 1);
    if (!magnitude_spectrum || !spectrum_image) {
        free(magnitude_spectrum);
        freeImage(spectrum_image);
        return NULL;
    }

    double max_magnitude = 0.0;

    // 2. Calculer la magnitude et la d√©caler (shift) pour centrer les basses fr√©quences
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            // Calculer la magnitude : |F(u,v)|
            double mag = complex_magnitude(fft_data[y][x]);

            // Mettre √† l'√©chelle logarithmique : log(1 + |F(u,v)|)
            // Le "+1" √©vite log(0) qui est ind√©fini.
            mag = log(1.0 + mag);

            // D√©calage des quadrants (FFT shift)
            // (y + height/2) % height et (x + width/2) % width
            // Cela d√©place le coin sup√©rieur gauche au centre.
            int shifted_y = (y + height / 2) % height;
            int shifted_x = (x + width / 2) % width;
            
            magnitude_spectrum[shifted_y * width + shifted_x] = mag;

            // Garder la trace du maximum pour la normalisation
            if (mag > max_magnitude) {
                max_magnitude = mag;
            }
        }
    }

    // 3. Normaliser les magnitudes entre 0 et 255
    if (max_magnitude > 0) {
        for (int i = 0; i < width * height; i++) {
            spectrum_image->data[i] = (uint8_t)((magnitude_spectrum[i] / max_magnitude) * 255.0);
        }
    }
    
    free(magnitude_spectrum);
    
    return spectrum_image;
}


void fft_lowpass_filter(Complex **fft_data, int width, int height, int radius) {
    int center_x = width / 2;
    int center_y = height / 2;
    double radius_squared = (double)radius * radius;

    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            // Calculer la distance par rapport au centre du spectre NON d√©cal√©
            // Le point (0,0) est le coin. On doit g√©rer les 4 quadrants.
            int dx = x < center_x ? x : width - x;
            int dy = y < center_y ? y : height - y;

            if ((double)(dx * dx + dy * dy) > radius_squared) {
                // Si le point est en dehors du cercle, on le met √† z√©ro.
                fft_data[y][x].real = 0;
                fft_data[y][x].imag = 0;
            }
        }
    }
}

void fft_highpass_filter(Complex **fft_data, int width, int height, int radius) {
    int center_x = width / 2;
    int center_y = height / 2;
    double radius_squared = (double)radius * radius;

    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            // Calculer la distance par rapport au centre du spectre NON d√©cal√©
            int dx = x < center_x ? x : width - x;
            int dy = y < center_y ? y : height - y;

            if ((double)(dx * dx + dy * dy) <= radius_squared) {
                // Si le point est √† l'int√©rieur du cercle, on le met √† z√©ro.
                fft_data[y][x].real = 0;
                fft_data[y][x].imag = 0;
            }
        }
    }
}

// Fonction pour appliquer UN filtre notch (et son sym√©trique)
void fft_notch_filter(Complex **fft_data, int width, int height, int u, int v, int radius) {
    double radius_squared = (double)radius * radius;
    int center_x = width / 2;
    int center_y = height / 2;

    // Coordonn√©es du bruit (u,v) et de son sym√©trique (-u,-v) par rapport au centre
    int u1 = u;
    int v1 = v;
    int u2 = -u;
    int v2 = -v;

    for (int y_shifted = 0; y_shifted < height; y_shifted++) {
        for (int x_shifted = 0; x_shifted < width; x_shifted++) {
            // Coordonn√©es par rapport au centre du spectre
            int current_u = x_shifted - center_x;
            int current_v = y_shifted - center_y;
            
            // Calcul des distances aux deux points de bruit
            double d1_sq = pow(current_u - u1, 2) + pow(current_v - v1, 2);
            double d2_sq = pow(current_u - u2, 2) + pow(current_v - v2, 2);

            if (d1_sq <= radius_squared || d2_sq <= radius_squared) {
                // Traduire les coordonn√©es d√©cal√©es en coordonn√©es de la matrice r√©elle
                int y_actual = (y_shifted + center_y) % height;
                int x_actual = (x_shifted + center_x) % width;
                
                fft_data[y_actual][x_actual].real = 0;
                fft_data[y_actual][x_actual].imag = 0;
            }
        }
    }
}


// Ajouter la nouvelle fonction √† la fin de fft.c
int fft_auto_notch_filter(Complex **fft_data, int width, int height, double threshold_factor, int radius) {
    long total_pixels = (long)width * height;
    double *magnitudes = malloc(total_pixels * sizeof(double));
    if (!magnitudes) return 0;

    int center_x = width / 2;
    int center_y = height / 2;

    // 1. Calculer le spectre de magnitude (non logarithmique, non d√©cal√©)
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            magnitudes[y * width + x] = complex_magnitude(fft_data[y][x]);
        }
    }
    
    // 2. Trouver une valeur de seuil robuste bas√©e sur la m√©diane
    // La m√©diane est moins sensible aux valeurs extr√™mes (les pics) que la moyenne.
    double *sorted_magnitudes = malloc(total_pixels * sizeof(double));
    if (!sorted_magnitudes) {
        free(magnitudes);
        return 0;
    }
    memcpy(sorted_magnitudes, magnitudes, total_pixels * sizeof(double));
    qsort(sorted_magnitudes, total_pixels, sizeof(double), compare_doubles);
    
    double median_magnitude = sorted_magnitudes[total_pixels / 2];
    double noise_threshold = median_magnitude * threshold_factor;

    free(sorted_magnitudes); // Plus besoin de la version tri√©e

    printf("D√©tection auto: M√©diane=%.2f, Seuil de bruit=%.2f\n", median_magnitude, noise_threshold);
    
    int detected_peaks_count = 0;
    NotchFilter detected_notches[20]; // Stocker les pics trouv√©s

    // 3. D√©tecter les pics qui d√©passent le seuil
    for (int y = 0; y < height; y++) {
        for (int x = 0; x < width; x++) {
            // Ignorer la zone centrale (basses fr√©quences)
            int dx = x < center_x ? x : width - x;
            int dy = y < center_y ? y : height - y;
            // On ignore un rayon de 5% autour du centre pour ne pas toucher √† l'image
            if (sqrt(dx*dx + dy*dy) < (width * 0.05)) {
                continue;
            }

            if (magnitudes[y * width + x] > noise_threshold) {
                if (detected_peaks_count < 20) {
                    // Convertir les coordonn√©es de la matrice en coordonn√©es relatives au centre
                    int u = (x + center_x) % width - center_x;
                    int v = (y + center_y) % height - center_y;
                    
                    // Ajouter le pic √† notre liste
                    detected_notches[detected_peaks_count].u = u;
                    detected_notches[detected_peaks_count].v = v;
                    detected_notches[detected_peaks_count].radius = radius;
                    detected_peaks_count++;
                }
            }
        }
    }
    
    free(magnitudes);

    // 4. Appliquer les filtres notch pour chaque pic d√©tect√©
    if (detected_peaks_count > 0) {
        printf("%d pic(s) de bruit d√©tect√©(s). Application des filtres...\n", detected_peaks_count);
        // On applique le filtre pour chaque pic. La sym√©trie est d√©j√† g√©r√©e dans fft_notch_filter.
        // On ne parcourt que la moiti√© des pics, car chaque appel traite une paire sym√©trique.
        for (int i = 0; i < detected_peaks_count; i++) {
             NotchFilter n = detected_notches[i];
             printf("  - Suppression du bruit autour de (%d, %d)\n", n.u, n.v);
             fft_notch_filter(fft_data, width, height, n.u, n.v, n.radius);
        }
    }

    // On retourne le nombre de paires (un pic et son sym√©trique)
    return detected_peaks_count / 2;
}// END OF FILE: src/fft/fft.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/filters/convolution.c

#include "filters/convolution.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

Image *apply_convolution(const Image *src, const Kernel *kernel) {
    if (!src || !kernel || !src->data || !kernel->data) {
        fprintf(stderr, "apply_convolution: Arguments invalides.\n");
        return NULL;
    }
    // Pour l'instant, on ne g√®re que les images en niveaux de gris
    if (src->channels != 1) {
        fprintf(stderr, "apply_convolution: Ne supporte que les images en niveaux de gris (1 canal).\n");
        return NULL;
    }

    // 1. Cr√©er une image de destination de la m√™me taille
    Image *dest = createImage(src->width, src->height, src->channels);
    if (!dest) {
        return NULL;
    }

    int kernel_center_x = kernel->width / 2;
    int kernel_center_y = kernel->height / 2;

    // 2. Parcourir chaque pixel de l'image source
    for (int y = 0; y < src->height; y++) {
        for (int x = 0; x < src->width; x++) {
            
            float sum = 0.0f;

            // 3. Appliquer le noyau sur le voisinage du pixel (x, y)
            for (int ky = 0; ky < kernel->height; ky++) {
                for (int kx = 0; kx < kernel->width; kx++) {
                    
                    // Coordonn√©es du pixel voisin dans l'image source
                    int ix = x + (kx - kernel_center_x);
                    int iy = y + (ky - kernel_center_y);

                    // 4. GESTION DES BORDS (strat√©gie : "clamp to edge")
                    // Si le voisin est en dehors de l'image, on prend le pixel le plus proche sur le bord.
                    if (ix < 0) ix = 0;
                    if (ix >= src->width) ix = src->width - 1;
                    if (iy < 0) iy = 0;
                    if (iy >= src->height) iy = src->height - 1;
                    
                    // Valeur du pixel voisin
                    uint8_t src_pixel = src->data[iy * src->width + ix];
                    // Coefficient du noyau
                    float kernel_val = kernel->data[ky * kernel->width + kx];

                    sum += src_pixel * kernel_val;
                }
            }

            // Normalisation et √©cr√™tage (clamping)
            if (sum < 0) sum = 0;
            if (sum > 255) sum = 255;
            
            dest->data[y * src->width + x] = (uint8_t)sum;
        }
    }

    return dest;
}

// **Explication de la Logique :**
// 1.  **Cr√©ation de l'image destination :** On alloue une nouvelle image pour le r√©sultat.
// 2.  **Double boucle sur l'image :** On visite chaque pixel `(x, y)` de l'image source.
// 3.  **Double boucle sur le noyau :** Pour chaque pixel, on applique le noyau. On superpose virtuellement le centre du noyau sur le pixel `(x, y)` et on regarde les pixels voisins.
// 4.  **Gestion des bords :** C'est la partie la plus d√©licate (slide 11 du cours). La strat√©gie `clamp to edge` (ou "r√©plication de bord") est simple et efficace : si le noyau d√©passe de l'image, on utilise la valeur du pixel le plus proche sur le bord. C'est mieux que de mettre du noir (ce qui cr√©erait un cadre sombre).
// 5.  **Calcul :** On fait la somme pond√©r√©e des pixels du voisinage et on stocke le r√©sultat (apr√®s l'avoir ramen√© dans l'intervalle) dans l'image de destination.
// END OF FILE: src/filters/convolution.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/filters/histogram_equalization.c

#include "filters/histogram_equalization.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

Image *equalize_histogram(const Image *src) {
    // 1. V√©rifications initiales robustes
    if (!src || !src->data || src->channels != 1) {
        fprintf(stderr, "equalize_histogram: Image invalide ou non support√©e (doit √™tre en niveaux de gris).\n");
        return NULL;
    }

    // V√©rifier que les dimensions sont valides
    if (src->width <= 0 || src->height <= 0) {
        fprintf(stderr, "equalize_histogram: Dimensions d'image invalides.\n");
        return NULL;
    }

    // Utiliser des types appropri√©s pour √©viter les d√©bordements
    size_t total_pixels = (size_t)src->width * (size_t)src->height;
    
    if (total_pixels == 0) {
        fprintf(stderr, "equalize_histogram: L'image est vide.\n");
        return NULL;
    }

    // 2. Calcul de l'histogramme
    long hist[256] = {0};
    for (size_t i = 0; i < total_pixels; i++) {
        uint8_t pixel_val = src->data[i];
        hist[pixel_val]++;
    }

    // 3. Calcul de la fonction de distribution cumulative (CDF)
    long cdf[256] = {0};
    cdf[0] = hist[0];
    for (int i = 1; i < 256; i++) {
        cdf[i] = cdf[i - 1] + hist[i];
    }

    // 4. Trouver la premi√®re valeur de CDF non nulle (cdf_min)
    long cdf_min = 0;
    for (int i = 0; i < 256; i++) {
        if (cdf[i] > 0) {
            cdf_min = cdf[i];
            break;
        }
    }

    // 5. Cr√©er la table de correspondance (LUT)
    uint8_t lut[256];
    long denominator = (long)total_pixels - cdf_min;

    if (denominator <= 0) {
        // Image uniforme, pas d'√©galisation possible
        fprintf(stderr, "Avertissement: Image uniforme, l'√©galisation n'a pas d'effet.\n");
        for (int i = 0; i < 256; i++) {
            lut[i] = (uint8_t)i;
        }
    } else {
        // Formule d'√©galisation d'histogramme standard
        double scale_factor = 255.0 / (double)denominator;
        for (int i = 0; i < 256; i++) {
            if (cdf[i] <= cdf_min) {
                lut[i] = 0;
            } else {
                long numerator = cdf[i] - cdf_min;
                double new_val = (double)numerator * scale_factor;
                
                // Arrondir et s'assurer que la valeur est dans [0, 255]
                int rounded = (int)(new_val + 0.5);
                if (rounded > 255) rounded = 255;
                if (rounded < 0) rounded = 0;
                
                lut[i] = (uint8_t)rounded;
            }
        }
    }

    // 6. Cr√©er l'image de destination
    Image *dest = createImage(src->width, src->height, src->channels);
    if (!dest) {
        fprintf(stderr, "equalize_histogram: √âchec de la cr√©ation de l'image de destination.\n");
        return NULL;
    }

    // 7. Appliquer la LUT pixel par pixel
    for (size_t i = 0; i < total_pixels; i++) {
        uint8_t original_value = src->data[i];
        dest->data[i] = lut[original_value];
    }
    
    return dest;
}// END OF FILE: src/filters/histogram_equalization.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/filters/pointwise.c

#include "filters/pointwise.h"
#include <stdio.h>

void linear_transform(Image *img, double a, double b) {
    if (!img || !img->data) {
        fprintf(stderr, "linear_transform: Image invalide.\n");
        return;
    }

    for (int i = 0; i < img->width * img->height * img->channels; i++) {
        double pixel = img->data[i];
        pixel = a * pixel + b;

        // √âcr√™tage (clamping)
        if (pixel < 0) {
            pixel = 0;
        } else if (pixel > 255) {
            pixel = 255;
        }
        img->data[i] = (uint8_t)pixel;
    }
    printf("Transformation lin√©aire appliqu√©e avec succ√®s.\n");
}

void saturated_transform(Image *img, int min_in, int max_in) {
    if (!img || !img->data) {
        fprintf(stderr, "saturated_transform: Image invalide.\n");
        return;
    }

    if (min_in >= max_in) {
        fprintf(stderr, "saturated_transform: min_in doit √™tre inf√©rieur √† max_in.\n");
        return;
    }

    for (int i = 0; i < img->width * img->height * img->channels; i++) {
        int pixel = img->data[i];

        if (pixel <= min_in) {
            pixel = 0;
        } else if (pixel >= max_in) {
            pixel = 255;
        } else {
            // Transformation lin√©aire entre min_in et max_in
            pixel = 255.0 * (pixel - min_in) / (max_in - min_in);
        }
        img->data[i] = (uint8_t)pixel;
    }
    printf("Transformation lin√©aire avec saturation appliqu√©e avec succ√®s.\n");
}



void apply_threshold(Image *img, uint8_t threshold) {
    if (!img || !img->data) {
        fprintf(stderr, "apply_threshold: Image invalide.\n");
        return;
    }
    
    // Pour l'instant, on ne g√®re que les niveaux de gris
    if (img->channels != 1) {
        fprintf(stderr, "apply_threshold: Ne supporte que les images en niveaux de gris.\n");
        return;
    }

    long total_pixels = (long)img->width * img->height;
    for (long i = 0; i < total_pixels; i++) {
        img->data[i] = (img->data[i] < threshold) ? 0 : 255;
    }
    
    printf("Seuillage appliqu√© avec le seuil %d.\n", threshold);
}// END OF FILE: src/filters/pointwise.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/filters/predefined_filters.c

#include "filters/predefined_filters.h"
#include "filters/convolution.h" // On a besoin de la structure Kernel et de apply_convolution
#include <stdlib.h>
#include <stdio.h>
#include <math.h> 
#include <string.h> 


// Fonction de comparaison requise par qsort pour trier des uint8_t.
static int compare_uint8(const void *a, const void *b) {
    uint8_t val1 = *(const uint8_t *)a;
    uint8_t val2 = *(const uint8_t *)b;
    if (val1 < val2) return -1;
    if (val1 > val2) return 1;
    return 0;
}

// --- Fonction interne pour factoriser le calcul de gradient ---
static Image* _apply_gradient_filter(const Image *src, const Kernel *kernel_x, const Kernel *kernel_y) {
    // 1. Appliquer les deux convolutions pour obtenir les gradients Gx et Gy
    Image *grad_x = apply_convolution(src, kernel_x);
    Image *grad_y = apply_convolution(src, kernel_y);

    if (!grad_x || !grad_y) {
        freeImage(grad_x);
        freeImage(grad_y);
        return NULL;
    }

    // 2. Cr√©er l'image pour le r√©sultat final (la magnitude)
    Image *result = createImage(src->width, src->height, src->channels);
    if (!result) {
        freeImage(grad_x);
        freeImage(grad_y);
        return NULL;
    }

    // 3. Combiner les gradients pour calculer la magnitude
    long total_pixels = (long)src->width * src->height * src->channels;
    for (long i = 0; i < total_pixels; i++) {
        // Approximation rapide et efficace de la magnitude: |Gx| + |Gy|
        // Notre apply_convolution borne d√©j√† √† 0, donc pas besoin de abs().
        int magnitude = grad_x->data[i] + grad_y->data[i];
        if (magnitude > 255) magnitude = 255;
        result->data[i] = (uint8_t)magnitude;
    }

    // 4. Lib√©rer la m√©moire des images interm√©diaires
    freeImage(grad_x);
    freeImage(grad_y);

    return result;
}

Image *apply_box_blur(const Image *src, int kernel_size) {
    if (kernel_size % 2 == 0) {
        fprintf(stderr, "apply_box_blur: La taille du noyau doit √™tre impaire.\n");
        return NULL;
    }

    // 1. Cr√©er le noyau de convolution pour le flou moyenneur
    Kernel kernel;
    kernel.width = kernel_size;
    kernel.height = kernel_size;
    
    int num_coeffs = kernel_size * kernel_size;
    kernel.data = (float*)malloc(num_coeffs * sizeof(float));
    if (!kernel.data) {
        perror("apply_box_blur: Impossible d'allouer la m√©moire pour le noyau");
        return NULL;
    }

    // Le filtre moyenneur a des coefficients √©gaux √† 1 / (nombre total de coeffs)
    // pour que l'image ne devienne ni plus claire, ni plus sombre.
    float coeff = 1.0f / num_coeffs;
    for (int i = 0; i < num_coeffs; i++) {
        kernel.data[i] = coeff;
    }

    // 2. Appeler le moteur de convolution g√©n√©rique avec le noyau que nous venons de cr√©er
    Image *result = apply_convolution(src, &kernel);

    // 3. Lib√©rer la m√©moire allou√©e pour le noyau
    free(kernel.data);

    return result;
}



Image *apply_gaussian_blur(const Image *src, int kernel_size) {
    if (kernel_size % 2 == 0) {
        fprintf(stderr, "apply_gaussian_blur: La taille du noyau doit √™tre impaire.\n");
        return NULL;
    }

    // 1. Cr√©er le noyau Gaussien
    Kernel kernel;
    kernel.width = kernel_size;
    kernel.height = kernel_size;
    
    int num_coeffs = kernel_size * kernel_size;
    kernel.data = (float*)malloc(num_coeffs * sizeof(float));
    if (!kernel.data) {
        perror("apply_gaussian_blur: Impossible d'allouer la m√©moire pour le noyau");
        return NULL;
    }

    float sum = 0.0f;
    int center = kernel_size / 2;
    float sigma = (float)kernel_size / 6.0; // Approximation raisonnable pour sigma

    // G√©n√©rer les coefficients du noyau Gaussien
    for (int y = 0; y < kernel_size; y++) {
        for (int x = 0; x < kernel_size; x++) {
            int dx = x - center;
            int dy = y - center;
            float val = exp(-((dx * dx + dy * dy) / (2 * sigma * sigma))) / (2 * M_PI * sigma * sigma);
            kernel.data[y * kernel_size + x] = val;
            sum += val;
        }
    }
    
    // Normaliser le noyau (s'assurer que la somme des coefficients est 1)
    for (int i = 0; i < num_coeffs; i++) {
        kernel.data[i] /= sum;
    }

    // 2. Appeler le moteur de convolution
    Image *result = apply_convolution(src, &kernel);

    // 3. Lib√©rer la m√©moire
    free(kernel.data);

    return result;
}

// Image *apply_sobel_filter(const Image *src) {
//     // Noyau de Sobel pour les gradients horizontaux (d√©tecte les contours verticaux)
//     float kx_data[] = {
//         -1, 0, 1,
//         -2, 0, 2,
//         -1, 0, 1
//     };
//     Kernel kernel_x = {3, 3, kx_data};

//     // Noyau de Sobel pour les gradients verticaux (d√©tecte les contours horizontaux)
//     float ky_data[] = {
//         -1, -2, -1,
//          0,  0,  0,
//          1,  2,  1
//     };
//     Kernel kernel_y = {3, 3, ky_data};

//     // 1. Appliquer les deux convolutions
//     Image *grad_x = apply_convolution(src, &kernel_x);
//     Image *grad_y = apply_convolution(src, &kernel_y);

//     if (!grad_x || !grad_y) {
//         freeImage(grad_x); // Lib√®re au cas o√π l'un des deux a r√©ussi
//         freeImage(grad_y);
//         return NULL;
//     }

//     // 2. Cr√©er une image pour le r√©sultat final
//     Image *result = createImage(src->width, src->height, src->channels);
//     if (!result) {
//         freeImage(grad_x);
//         freeImage(grad_y);
//         return NULL;
//     }

//     // 3. Combiner les deux gradients (magnitude)
//     for (int i = 0; i < src->width * src->height * src->channels; i++) {
//         // La convolution peut donner des r√©sultats "n√©gatifs", mais ils sont stock√©s 
//         // comme des entiers. Le calcul correct n√©cessite une conversion.
//         // Ici, on fait une approximation simple avec la valeur absolue.
//         // Pour une impl√©mentation parfaite, apply_convolution devrait retourner
//         // des float, mais restons simples pour l'instant.
//         float gx = grad_x->data[i];
//         float gy = grad_y->data[i];
        
//         // Calcul de la magnitude : sqrt(gx^2 + gy^2)
//         float magnitude = sqrt(gx * gx + gy * gy);

//         if (magnitude > 255) magnitude = 255;
//         result->data[i] = (uint8_t)magnitude;
//     }

//     // 4. Lib√©rer les images interm√©diaires
//     freeImage(grad_x);
//     freeImage(grad_y);

//     return result;
// }


Image *apply_sobel_filter(const Image *src) {
    float kx_data[] = {-1, 0, 1, -2, 0, 2, -1, 0, 1};
    float ky_data[] = {-1, -2, -1, 0, 0, 0, 1, 2, 1};
    Kernel kernel_x = {3, 3, kx_data};
    Kernel kernel_y = {3, 3, ky_data};
    return _apply_gradient_filter(src, &kernel_x, &kernel_y);
}

Image *apply_prewitt_filter(const Image *src) {
    float kx_data[] = {-1, 0, 1, -1, 0, 1, -1, 0, 1};
    float ky_data[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};
    Kernel kernel_x = {3, 3, kx_data};
    Kernel kernel_y = {3, 3, ky_data};
    return _apply_gradient_filter(src, &kernel_x, &kernel_y);
}

Image *apply_roberts_filter(const Image *src) {
    // Le noyau de Roberts est 2x2. On l'applique comme un noyau 3x3 avec des z√©ros.
    float kx_data[] = {1, 0, 0, 0, -1, 0, 0, 0, 0};
    float ky_data[] = {0, 1, 0, -1, 0, 0, 0, 0, 0};
    Kernel kernel_x = {3, 3, kx_data};
    Kernel kernel_y = {3, 3, ky_data};
    return _apply_gradient_filter(src, &kernel_x, &kernel_y);
}










// ... √† la fin de src/filters/predefined_filters.c ...

Image *apply_sharpen_filter(const Image *src) {
    // 1. D√©finir le noyau de convolution Laplacien.
    // Ce noyau est tr√®s bon pour d√©tecter les contours dans toutes les directions.
    // La somme des coefficients est 0, ce qui signifie que les zones plates
    // de l'image donneront un r√©sultat proche de 0.
    float laplacian_data[] = {
         0, -1,  0,
        -1,  4, -1,
         0, -1,  0
    };
    Kernel laplacian_kernel = {3, 3, laplacian_data};

    // 2. Appliquer la convolution pour obtenir l'image des contours.
    // Cette image sera principalement noire (0) avec les contours en blanc.
    Image *edges = apply_convolution(src, &laplacian_kernel);
    if (!edges) {
        fprintf(stderr, "apply_sharpen_filter: √âchec de l'extraction des contours.\n");
        return NULL;
    }

    // 3. Cr√©er une copie de l'image originale pour y soustraire les contours.
    // On ne peut pas modifier l'image source directement.
    Image *result = createImage(src->width, src->height, src->channels);
    if (!result) {
        freeImage(edges);
        return NULL;
    }
    memcpy(result->data, src->data, src->width * src->height * src->channels);

    // 4. Soustraire les contours de l'image copi√©e.
    for (int i = 0; i < src->width * src->height * src->channels; i++) {
        // La valeur du pixel dans 'result' (l'original)
        int original_pixel = result->data[i];
        
        // La valeur du contour (plus c'est blanc, plus le contour est fort)
        int edge_pixel = edges->data[i];

        // On soustrait. Le r√©sultat est un entier qui peut √™tre n√©gatif.
        int final_pixel = original_pixel - edge_pixel;
        
        // √âcr√™tage (clamping) pour s'assurer que la valeur reste entre 0 et 255.
        if (final_pixel < 0) final_pixel = 0;
        if (final_pixel > 255) final_pixel = 255;
        
        result->data[i] = (uint8_t)final_pixel;
    }

    // 5. Lib√©rer la m√©moire de l'image interm√©diaire des contours.
    freeImage(edges);

    return result;
}



Image *apply_median_filter(const Image *src, int kernel_size) {
    if (!src || !src->data || src->channels != 1) {
        fprintf(stderr, "apply_median_filter: Image invalide ou non support√©e.\n");
        return NULL;
    }
    if (kernel_size % 2 == 0) {
        fprintf(stderr, "apply_median_filter: La taille du noyau doit √™tre impaire.\n");
        return NULL;
    }

    Image *dest = createImage(src->width, src->height, src->channels);
    if (!dest) return NULL;

    int kernel_center = kernel_size / 2;
    int num_neighbors = kernel_size * kernel_size;
    int median_index = num_neighbors / 2;

    // Allouer un buffer pour stocker les valeurs du voisinage
    uint8_t *neighborhood = (uint8_t *)malloc(num_neighbors * sizeof(uint8_t));
    if (!neighborhood) {
        perror("apply_median_filter: Impossible d'allouer le buffer du voisinage");
        freeImage(dest);
        return NULL;
    }

    // Parcourir chaque pixel de l'image
    for (int y = 0; y < src->height; y++) {
        for (int x = 0; x < src->width; x++) {
            
            int neighbor_idx = 0;
            // Collecter les valeurs des pixels du voisinage
            for (int ky = 0; ky < kernel_size; ky++) {
                for (int kx = 0; kx < kernel_size; kx++) {
                    int ix = x + (kx - kernel_center);
                    int iy = y + (ky - kernel_center);

                    // G√©rer les bords par r√©plication (clamp to edge)
                    if (ix < 0) ix = 0;
                    if (ix >= src->width) ix = src->width - 1;
                    if (iy < 0) iy = 0;
                    if (iy >= src->height) iy = src->height - 1;

                    neighborhood[neighbor_idx++] = src->data[iy * src->width + ix];
                }
            }

            // Trier le voisinage pour trouver la m√©diane
            qsort(neighborhood, num_neighbors, sizeof(uint8_t), compare_uint8);
            
            // Assigner la valeur m√©diane au pixel de destination
            dest->data[y * src->width + x] = neighborhood[median_index];
        }
    }

    free(neighborhood);
    return dest;
}

// END OF FILE: src/filters/predefined_filters.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/io/pnm.c

#include "io/pnm.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Fonction utilitaire pour ignorer les commentaires dans l'en-t√™te PNM
void ignore_comments(FILE *fp) {
    int ch;
    char line[1024];
    while ((ch = fgetc(fp)) != EOF && (ch == '#' || ch == '\n' || ch == ' ' || ch == '\t' || ch == '\r')) {
        if (ch == '#') {
            if (fgets(line, sizeof(line), fp) == NULL) break;
        }
    }
    ungetc(ch, fp); // Remet le dernier caract√®re lu dans le flux
}

Image *loadPNM(const char *filename) {
    FILE *fp = fopen(filename, "rb");
    if (!fp) {
        perror("loadPNM: Impossible d'ouvrir le fichier");
        return NULL;
    }

    char magic_number[3];
    if (fscanf(fp, "%2s", magic_number) != 1) {
        fprintf(stderr, "loadPNM: Erreur de lecture du nombre magique.\n");
        fclose(fp);
        return NULL;
    }

    int channels;
    if (strcmp(magic_number, "P5") == 0) {
        channels = 1; // PGM
    } else if (strcmp(magic_number, "P6") == 0) {
        channels = 3; // PPM
    } else {
        fprintf(stderr, "loadPNM: Format non support√© '%s'. Uniquement P5 (PGM) et P6 (PPM).\n", magic_number);
        fclose(fp);
        return NULL;
    }

    ignore_comments(fp);
    int width, height, max_val;
    if (fscanf(fp, "%d %d", &width, &height) != 2) {
        fprintf(stderr, "loadPNM: Impossible de lire les dimensions.\n");
        fclose(fp);
        return NULL;
    }

    ignore_comments(fp);
    if (fscanf(fp, "%d", &max_val) != 1 || max_val != 255) {
        fprintf(stderr, "loadPNM: Profondeur de couleur non support√©e (doit √™tre 255).\n");
        fclose(fp);
        return NULL;
    }
    
    // Consomme le dernier caract√®re de nouvelle ligne avant les donn√©es binaires
    fgetc(fp); 

    Image *img = createImage(width, height, channels);
    if (!img) {
        fclose(fp);
        return NULL;
    }

    size_t pixels_to_read = width * height * channels;
    if (fread(img->data, sizeof(uint8_t), pixels_to_read, fp) != pixels_to_read) {
        fprintf(stderr, "loadPNM: Erreur de lecture des donn√©es de pixels ou fichier corrompu.\n");
        freeImage(img);
        fclose(fp);
        return NULL;
    }

    fclose(fp);
    printf("Image '%s' charg√©e avec succ√®s (%dx%d).\n", filename, width, height);
    return img;
}

int savePNM(const Image *img, const char *filename) {
    FILE *fp = fopen(filename, "wb");
    if (!fp) {
        perror("savePNM: Impossible d'ouvrir le fichier en √©criture");
        return -1;
    }

    // Choisit le format PGM ou PPM en fonction des canaux
    if (img->channels == 1) {
        fprintf(fp, "P5\n");
    } else if (img->channels == 3) {
        fprintf(fp, "P6\n");
    } else {
        fprintf(stderr, "savePNM: Nombre de canaux non support√© pour PNM: %d\n", img->channels);
        fclose(fp);
        return -1;
    }

    fprintf(fp, "%d %d\n", img->width, img->height);
    fprintf(fp, "255\n");

    size_t pixels_to_write = img->width * img->height * img->channels;
    if (fwrite(img->data, sizeof(uint8_t), pixels_to_write, fp) != pixels_to_write) {
        fprintf(stderr, "savePNM: Erreur lors de l'√©criture des donn√©es.\n");
        fclose(fp);
        return -1;
    }

    fclose(fp);
    printf("Image sauvegard√©e avec succ√®s dans '%s'.\n", filename);
    return 0;
}

// END OF FILE: src/io/pnm.c

//---> PATH: /home/atabong/Documents/projet/imgproc/src/main.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h> // Pour exit

#include "io/pnm.h"
#include "analysis/histogram.h"
#include "analysis/stats.h"
#include "filters/pointwise.h"
#include "filters/predefined_filters.h"
#include "filters/histogram_equalization.h"
#include "cli/parser.h"
#include "fft/fft.h"

int main(int argc, char *argv[]) {

    Arguments args = parse_args(argc, argv); // Utiliser la fonction parse_args mise √† jour

    // 1. Charger l'image d'entr√©e
    Image *img = loadPNM(args.input_path);
    if (!img) {
        fprintf(stderr, "Impossible de charger l'image '%s'.\n", args.input_path);
        return 1;
    }

    // 2. Analyse de l'image (si demand√©)
    if (args.show_histogram) {
        int histogram[256];
        calculate_histogram(img, histogram);

        // Cr√©er l'image de l'histogramme
        Image *hist_img = create_histogram_image(histogram, 512, 256); // Dimensions 512x256
        if (hist_img) {
            // Sauvegarder l'image de l'histogramme
            if (savePNM(hist_img, args.histogram_output_path) != 0) {
                fprintf(stderr, "Erreur lors de la sauvegarde de l'histogramme.\n");
            }
            freeImage(hist_img); // Ne pas oublier de la lib√©rer !
        }
    }
    if (args.show_luminance) {
        double luminance = calculate_luminance(img);
        if (luminance >= 0) {
            printf("Luminance: %f\n", luminance);
        }
    }
    if (args.show_contrast) {
        double contrast = calculate_contrast(img);
        if (contrast >= 0) {
            printf("Contraste: %f\n", contrast);
        }
    }
    // ------------------ Transformations ------------------
    if (img) {
        if (args.linear_gain != 1.0 || args.linear_bias != 0.0) {
            linear_transform(img, args.linear_gain, args.linear_bias);
        }
        if (args.saturated_min != -1 && args.saturated_max != -1) {
            saturated_transform(img, args.saturated_min, args.saturated_max);
        }
    }
    // -------------------------------------------------------

    // --- Section des transformations par convolution ---
    if (args.blur_kernel_size > 0) {
        printf("Application d'un flou %dx%d...\n", args.blur_kernel_size, args.blur_kernel_size);
        Image *blurred_img = apply_box_blur(img, args.blur_kernel_size);
        if (blurred_img) {
            // Le r√©sultat est dans blurred_img. L'ancienne image 'img' n'est plus utile.
            freeImage(img);       // On lib√®re l'ancienne image
            img = blurred_img;    // Et on pointe 'img' vers la nouvelle image flout√©e
        }
    }

    if (args.gaussian_blur_kernel_size > 0) {
        printf("Application d'un flou Gaussien %dx%d...\n", args.gaussian_blur_kernel_size, args.gaussian_blur_kernel_size);
        Image *blurred_img = apply_gaussian_blur(img, args.gaussian_blur_kernel_size);
        if (blurred_img) {
            freeImage(img);
            img = blurred_img;
        }
    }

    if (args.apply_sobel) {
        printf("Application du filtre de Sobel...\n");
        Image *sobel_img = apply_sobel_filter(img);
        if (sobel_img) {
            freeImage(img);
            img = sobel_img;
        }
    }

    if (args.apply_sharpen) {
        printf("Application du filtre de nettet√©...\n");
        Image *sharpened_img = apply_sharpen_filter(img);
        if (sharpened_img) {
            freeImage(img);       // Lib√®re l'ancienne image
            img = sharpened_img;  // Pointe vers la nouvelle
        }
    }
    if (args.apply_equalization) {
        printf("Application de l'√©galisation d'histogramme...\n");
        Image *equalized_img = equalize_histogram(img);
        if (equalized_img) {
            freeImage(img);       // Lib√®re l'ancienne image
            img = equalized_img;  // Pointe vers la nouvelle
        }
    }
    if (args.median_kernel_size > 0) {
        printf("Application du filtre m√©dian %dx%d...\n", args.median_kernel_size, args.median_kernel_size);
        Image *median_img = apply_median_filter(img, args.median_kernel_size);
        if (median_img) {
            freeImage(img);       // Lib√®re l'ancienne image
            img = median_img;     // Pointe vers la nouvelle
        }
    }
    if (args.test_fft) {
        printf("Test du module FFT...\n");
        int fft_w, fft_h;
        Complex **fft_result = fft2d(img, &fft_w, &fft_h);
        if (fft_result) {
            printf("FFT calcul√©e avec succ√®s (dimensions : %dx%d).\n", fft_w, fft_h);
            
            // Test de l'inverse
            Image *inversed_img = ifft2d(fft_result, fft_w, fft_h);
            if(inversed_img) {
                printf("FFT Inverse calcul√©e avec succ√®s.\n");
                // Sauvegarder pour v√©rifier si l'image est revenue √† l'original (√† peu pr√®s)
                savePNM(inversed_img, "test_ifft.pgm");
                freeImage(inversed_img);
            }

            free_fft_data(fft_result, fft_h);
        } else {
            fprintf(stderr, "Le calcul de la FFT a √©chou√©.\n");
        }
    }
    if (args.fft_spectrum_path) {
        printf("Calcul du spectre de Fourier...\n");
        int fft_w, fft_h;
        Complex **fft_result = fft2d(img, &fft_w, &fft_h);
        if (fft_result) {
            Image *spectrum = create_spectrum_image(fft_result, fft_w, fft_h);
            if (spectrum) {
                if (savePNM(spectrum, args.fft_spectrum_path) == 0) {
                    printf("Spectre de Fourier sauvegard√© dans '%s'.\n", args.fft_spectrum_path);
                }
                freeImage(spectrum);
            }
            free_fft_data(fft_result, fft_h);
        }
    }

    // --- Pipeline de Filtrage Fr√©quentiel ---
    if (args.fft_lowpass_radius > 0 || args.fft_highpass_radius > 0) {
        printf("D√©but du filtrage fr√©quentiel...\n");
        
        // √âtape 1: Appliquer la FFT
        int fft_w, fft_h;
        Complex **fft_result = fft2d(img, &fft_w, &fft_h);
        
        if (fft_result) {
            // √âtape 2: Appliquer les filtres demand√©s
            if (args.fft_lowpass_radius > 0) {
                printf("Application du filtre passe-bas fr√©quentiel (rayon=%d)...\n", args.fft_lowpass_radius);
                fft_lowpass_filter(fft_result, fft_w, fft_h, args.fft_lowpass_radius);
            }
            if (args.fft_highpass_radius > 0) {
                printf("Application du filtre passe-haut fr√©quentiel (rayon=%d)...\n", args.fft_highpass_radius);
                fft_highpass_filter(fft_result, fft_w, fft_h, args.fft_highpass_radius);
            }

            if (args.auto_notch_radius > 0) {
                printf("Lancement de la d√©tection et suppression automatique du bruit...\n");
                // On utilise un facteur de seuil de 10.0 par d√©faut. C'est une bonne valeur de d√©part.
                double default_threshold_factor = 10.0;
                fft_auto_notch_filter(fft_result, fft_w, fft_h, default_threshold_factor, args.auto_notch_radius);
            }



            // √âtape 3: Appliquer la FFT Inverse pour revenir au domaine spatial
            Image *filtered_img = ifft2d(fft_result, fft_w, fft_h);
            if (filtered_img) {
                // Remplacer l'image originale par le r√©sultat du filtrage
                freeImage(img);
                img = filtered_img;
            }

            // Nettoyer la m√©moire des donn√©es FFT
            free_fft_data(fft_result, fft_h);
        }
    }

    if (args.apply_prewitt) {
        printf("Application du filtre de Prewitt...\n");
        Image *prewitt_img = apply_prewitt_filter(img);
        if (prewitt_img) {
            freeImage(img);
            img = prewitt_img;
        }
    }
    if (args.apply_roberts) {
        printf("Application du filtre de Roberts...\n");
        Image *roberts_img = apply_roberts_filter(img);
        if (roberts_img) {
            freeImage(img);
            img = roberts_img;
        }
    }




    // Le seuillage doit √™tre appliqu√© APRES les autres filtres.
    // On le place juste avant la sauvegarde.
    if (args.threshold_value != -1) {
        apply_threshold(img, (uint8_t)args.threshold_value);
    }
    // -------------------------------------------------------


    // 3. Sauvegarder l'image dans le fichier de sortie
    if (savePNM(img, args.output_path) != 0) {
        fprintf(stderr, "Impossible de sauvegarder l'image dans '%s'.\n", args.output_path);
        freeImage(img);
        return 1;
    }

    // 4. Lib√©rer la m√©moire
    freeImage(img);

    printf("Op√©ration termin√©e avec succ√®s.\n");
    return 0;
}// END OF FILE: src/main.c

